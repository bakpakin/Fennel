.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "fennel-api" "3" "2023-07-05" "fennel 1.3.1-dev" "Fennel\[aq]s Lua API"
.hy
.SH NAME
.PP
fennel-api - Fennel\[aq]s Lua API
.SH DESCRIPTION
.PP
The \f[V]fennel\f[R] module provides the following functions for use
when embedding Fennel in a Lua program.
If you\[aq]re writing a pure Fennel program or working on a system that
already has Fennel support, you probably don\[aq]t need this.
.PP
Only the \f[V]fennel\f[R] module is part of the public API.
The other modules are implementation details subject to change.
Most functions will \f[V]error\f[R] upon failure.
.PP
Any time a function takes an \f[V]options\f[R] table argument, that
table will usually accept these fields:
.IP \[bu] 2
\f[V]allowedGlobals\f[R]: a sequential table of strings of the names of
globals which the compiler will allow references to.
Set to false to disable checks.
Defaults to the contents of the \f[V]env\f[R] table, if provided, or the
current environment.
.IP \[bu] 2
\f[V]correlate\f[R]: when this is set, Fennel attempts to emit Lua where
the line numbers match up with the Fennel input code; useful for
situation where code that isn\[aq]t under your control will print the
stack traces.
.IP \[bu] 2
\f[V]useMetadata\f[R] \f[I](since 0.3.0)\f[R]: enables or disables
metadata, allowing use of the \f[V],doc\f[R] repl command.
Intended for development purposes (see performance note); defaults to
true for REPL only.
.IP \[bu] 2
\f[V]requireAsInclude\f[R] \f[I](since 0.3.0)\f[R]: Alias any static
\f[V]require\f[R] calls to the \f[V]include\f[R] special, embedding the
module code inline in the compiled output.
If the module name isn\[aq]t a string literal that is resolvable at
compile time it falls back to \f[V]require\f[R] at runtime.
Can be used to embed both Fennel and Lua modules.
.IP \[bu] 2
\f[V]env\f[R]: an environment table in which to run the code; see the
Lua manual.
.IP \[bu] 2
\f[V]compilerEnv\f[R]: an environment table in which to run
compiler-scoped code for macro definitions and \f[V]eval-compiler\f[R]
calls.
Internal Fennel functions such as \f[V]list\f[R], \f[V]sym\f[R], etc.
will be exposed in addition to this table.
Defaults to a table containing limited known-safe globals.
Pass \f[V]_G\f[R] to disable sandboxing.
.IP \[bu] 2
\f[V]unfriendly\f[R]: disable friendly compiler/parser error messages.
.IP \[bu] 2
\f[V]plugins\f[R]: list of compiler plugins.
.IP \[bu] 2
\f[V]error-pinpoint\f[R]: a list of two strings indicating what to wrap
compile errors in
.PP
You can pass the string \f[V]\[dq]_COMPILER\[dq]\f[R] as the value for
\f[V]env\f[R]; it will cause the code to be run/compiled in a context
which has all compiler-scoped values available.
This can be useful for macro modules or compiler plugins.
.PP
Note that only the \f[V]fennel\f[R] module is part of the public API.
The other modules (\f[V]fennel.utils\f[R], \f[V]fennel.compiler\f[R],
etc) should be considered compiler internals subject to change.
.PP
If you are embedding Fennel in a context where ANSI escape codes are not
interpreted, you can set \f[V]error-pinpoint\f[R] to \f[V]false\f[R] to
disable the highlighting of compiler and parse errors.
.SH START A CONFIGURABLE REPL
.IP
.nf
\f[C]
fennel.repl([options])
\f[R]
.fi
.PP
Takes these additional options:
.IP \[bu] 2
\f[V]readChunk()\f[R]: a function that when called, returns a string of
source code.
The empty is string or nil is used as the end of source marker.
.IP \[bu] 2
\f[V]pp\f[R]: a pretty-printer function to apply on values (default:
\f[V]fennel.view\f[R]).
.IP \[bu] 2
\f[V]onValues(values)\f[R]: a function that will be called on all
returned top level values.
.IP \[bu] 2
\f[V]onError(errType, err, luaSource)\f[R]: a function that will be
called on each error.
\f[V]errType\f[R] is a string with the type of error, can be either,
\[aq]parse\[aq], \[aq]compile\[aq], \[aq]runtime\[aq], or \[aq]lua\[aq].
\f[V]err\f[R] is the error message, and \f[V]luaSource\f[R] is the
source of the generated lua code.
.PP
By default, metadata will be enabled and you can view function
signatures and docstrings with the \f[V],doc\f[R] command in the REPL.
.SH EVAULATE A STRING OF FENNEL
.IP
.nf
\f[C]
local result = fennel.eval(str[, options[, ...]])
\f[R]
.fi
.PP
The \f[V]options\f[R] table may also contain:
.IP \[bu] 2
\f[V]filename\f[R]: override the filename that Lua thinks the code came
from.
.PP
Additional arguments beyond \f[V]options\f[R] are passed to the code and
available as \f[V]...\f[R].
.SH EVALUATE A FILE OF FENNEL
.IP
.nf
\f[C]
local result = fennel.dofile(filename[, options[, ...]])
\f[R]
.fi
.PP
Additional arguments beyond \f[V]options\f[R] are passed to the code and
available as \f[V]...\f[R].
.SH USE LUA\[aq]S BUILT-IN REQUIRE FUNCTION
.IP
.nf
\f[C]
require(\[dq]fennel\[dq]).install().dofile(\[dq]main.fnl\[dq])
\f[R]
.fi
.PP
This is the equivalent of this code:
.IP
.nf
\f[C]
local fennel = require(\[dq]fennel\[dq])
table.insert(package.loaders or package.searchers, fennel.searcher)
fennel.dofile(\[dq]main.fnl\[dq]) -- require calls in main.fnl can load fennel modules
\f[R]
.fi
.PP
Normally Lua\[aq]s \f[V]require\f[R] function only loads modules written
in Lua, but you can install \f[V]fennel.searcher\f[R] into
\f[V]package.searchers\f[R] (or in Lua 5.1 \f[V]package.loaders\f[R]) to
teach it how to load Fennel code.
.PP
If you would rather change some of the options you can use
\f[V]fennel.makeSearcher(options)\f[R] to get a searcher function
that\[aq]s equivalent to \f[V]fennel.searcher\f[R] but overrides the
default \f[V]options\f[R] table.
.PP
The \f[V]require\f[R] function is different from \f[V]fennel.dofile\f[R]
in that it searches the directories in \f[V]fennel.path\f[R] for
\f[V].fnl\f[R] files matching the module name, and also in that it
caches the loaded value to return on subsequent calls, while
\f[V]fennel.dofile\f[R] will reload each time.
The behavior of \f[V]fennel.path\f[R] mirrors that of Lua\[aq]s
\f[V]package.path\f[R].
There is also a \f[V]fennel.macro-path\f[R] which is used to look up
macro modules.
.PP
If you install Fennel into \f[V]package.searchers\f[R] then you can use
the repl\[aq]s \f[V],reload mod\f[R] command to reload modules that have
been loaded with \f[V]require\f[R].
.SH MACRO SEARCHERS
.PP
The compiler sandbox makes it so that the module system is also isolated
from the rest of the system, so the above \f[V]require\f[R] calls will
not work from inside macros.
However, there is a separate \f[V]fennel.macro-searchers\f[R] table
which can be used to allow different modules to be loaded inside macros.
By default it includes a searcher to load sandboxed Fennel modules and a
searcher to load sandboxed Lua modules, but if you disable the compiler
sandbox you may want to replace these with searchers which can load
arbitrary modules.
.PP
The default \f[V]fennel.macro-searchers\f[R] functions also cannot load
C modules.
Here\[aq]s an example of some code which would allow that to work:
.IP
.nf
\f[C]
table.insert(fennel[\[dq]macro-searchers\[dq]], function(module_name)
  local filename = fennel[\[dq]search-module\[dq]](module_name, package.cpath)
  if filename then
    local func = \[dq]luaopen_\[dq] .. module_name
    return function() return package.loadlib(filename, func) end, filename
  end
end)
\f[R]
.fi
.PP
Macro searchers store loaded macro modules in the
\f[V]fennel.macro-loaded\f[R] table which works the same as
\f[V]package.loaded\f[R] but for macro modules.
.SH GET FENNEL-AWARE STACK TRACES.
.PP
The \f[V]fennel.traceback\f[R] function works like Lua\[aq]s
\f[V]debug.traceback\f[R] function, except it tracks line numbers from
Fennel code correctly.
.PP
If you are working on an application written in Fennel, you can override
the default traceback function to replace it with Fennel\[aq]s:
.IP
.nf
\f[C]
debug.traceback = fennel.traceback
\f[R]
.fi
.PP
Note that some systems print stack traces from C, which will not be
affected.
.SH SEARCH THE PATH FOR A MODULE WITHOUT LOADING IT
.IP
.nf
\f[C]
print(fennel.searchModule(\[dq]my.mod\[dq], package.path))
\f[R]
.fi
.PP
If you just want to find the file path that a module would resolve to
without actually loading it, you can use \f[V]fennel.searchModule\f[R].
The first argument is the module name, and the second argument is the
path string to search.
If none is provided, it defaults to Fennel\[aq]s own path.
.PP
Returns \f[V]nil\f[R] if the module is not found on the path.
.SH COMPILE A STRING INTO LUA
.IP
.nf
\f[C]
local lua = fennel.compileString(str[, options])
\f[R]
.fi
.PP
Accepts \f[V]indent\f[R] as a string in \f[V]options\f[R] causing output
to be indented using that string, which should contain only whitespace
if provided.
Unlike the other functions, the \f[V]compile\f[R] functions default to
performing no global checks, though you can pass in an
\f[V]allowedGlobals\f[R] table in \f[V]options\f[R] to enable it.
.PP
Accepts \f[V]filename\f[R] in \f[V]options\f[R] as in
\f[V]fennel.eval\f[R].
.SH COMPILE AN ITERATOR OF BYTES INTO A STRING OF LUA
.PP
This is useful when streaming data into the compiler to allow you to
avoid loading all the code into a single string in one go.
.IP
.nf
\f[C]
local lua = fennel.compileStream(strm[, options])
\f[R]
.fi
.PP
Accepts \f[V]indent\f[R] and \f[V]filename\f[R] in \f[V]options\f[R] as
per above.
.SH COMPILE AN AST DATA STRUCTURE INTO LUA SOURCE CODE
.PP
The \f[V]ast\f[R] here can be gotten from \f[V]fennel.parser\f[R].
.IP
.nf
\f[C]
local lua = fennel.compile(ast[, options])
\f[R]
.fi
.PP
Accepts \f[V]indent\f[R] and \f[V]filename\f[R] in \f[V]options\f[R] as
per above.
.SH CONVERT TEXT INTO AST NODE(S)
.PP
The \f[V]fennel.parser\f[R] function returns a stateful iterator
function.
If a form was successfully read, it returns true followed by the AST
node.
Returns nil when it reaches the end.
Raises an error if it can\[aq]t parse the input.
.IP
.nf
\f[C]
local parse = fennel.parser(text)
local ok, ast = assert(parse()) -- just get the first form

-- Or use in a for loop
for ok, ast in parse do
  if ok then
    print(fennel.view(ast))
  end
end
\f[R]
.fi
.PP
The first argument can either be a string or a function that returns one
byte at a time.
It takes two optional arguments; a filename and a table of options.
Supported options are both booleans that default to false:
.IP \[bu] 2
\f[V]unfriendly\f[R]: disable enhanced parse error reporting
.IP \[bu] 2
\f[V]comments\f[R]: include comment nodes in AST
.IP \[bu] 2
\f[V]plugins\f[R]: \f[I](since 1.2.0)\f[R] An optional list of compiler
plugins.
.PP
The list of common options at the top of this document do not apply
here.
.SH AST NODE DEFINITION
.PP
The AST returned by the parser consists of data structures representing
the code.
Passing AST nodes to the \f[V]fennel.view\f[R] function will give you a
string which should round-trip thru the parser to give you the same data
back.
The same is true with \f[V]tostring\f[R], except it does not work with
non-sequence tables.
.PP
The \f[V]fennel.ast-source\f[R] function takes an AST node and returns a
table with source data around filename, line number, et in it, if
possible.
Some AST nodes cannot provide this data, for instance numbers, strings,
and booleans, or symbols constructed within macros using the
\f[V]sym\f[R] function instead of backtick.
.PP
AST nodes can be any of these types:
.SS list
.PP
A list represents a call to function/macro, or destructuring multiple
return values in a binding context.
It\[aq]s represented as a table which can be identified using the
\f[V]fennel.list?\f[R] predicate function or constructed using
\f[V]fennel.list\f[R] which takes any number of arguments for the
contents of the list.
.PP
Note that lists are compile-time constructs in Fennel.
They do not exist at runtime, except in such cases as the compiler is in
use at runtime.
.PP
The list also contains these keys indicating where it was defined:
\f[V]filename\f[R], \f[V]line\f[R], \f[V]col\f[R], \f[V]endcol\f[R],
\f[V]bytestart\f[R], and \f[V]byteend\f[R].
This data is used for stack traces and for pinpointing compiler error
messages.
Note that column numbers are based on character count, which does not
always correspond to visual columns; for instance \[dq]วัด\[dq] is three
characters but only two visual columns.
.SS sequence/kv table
.PP
These are table literals in Fennel code produced by square brackets
(sequences) or curly brackets (kv tables).
Sequences can be identified using the \f[V]fennel.sequence?\f[R]
function and constructed using \f[V]fennel.sequence\f[R].
There is no predicate or constructor for kv tables; any table which is
not one of the other types is assumed to be one of these.
.PP
At runtime there is no difference between sequences and kv tables which
use monotonically increasing integer keys, but the parser is able to
distinguish between them to improve error reporting.
.PP
Sequences and kv tables have their source data in \f[V]filename\f[R],
\f[V]line\f[R], etc keys of their metatable.
The metatable for kv tables also includes a \f[V]keys\f[R] sequence
which tells you which order the keys appeared originally, since kv
tables are unordered and there would otherwise be no way to reconstruct
this information.
.SS symbol
.PP
Symbols typically represent identifiers in Fennel code.
Symbols can be identified with \f[V]fennel.sym?\f[R] and constructed
with \f[V]fennel.sym\f[R] which takes a string name as its first
argument and a source data table as the second.
Symbols are represented as tables which store their source data
(\f[V]filename\f[R], \f[V]line\f[R], \f[V]col\f[R], etc) in fields on
themselves.
Unlike the other tables in the AST, they do not represent collections;
they are used as scalar types.
.PP
Symbols can refer not just directly to locals, but also to table
references like \f[V]tbl.x\f[R] for field lookup or
\f[V]access.channel:deny\f[R] for method invocation.
The \f[V]fennel.multi-sym?\f[R] function will return a table containing
the segments if the symbol if it is one of these, or nil otherwise.
.PP
\f[B]Note:\f[R] \f[V]nil\f[R] is not a valid AST; code that references
nil will have the symbol named \f[V]\[dq]nil\[dq]\f[R] which
unfortunately prints in a way that is visually indistinguishable from
actual \f[V]nil\f[R].
.PP
The \f[V]fennel.sym-char?\f[R] function will tell you if a given
character is allowed to be used in the name of a symbol.
.SS vararg
.PP
This is a special type of symbol-like construct (\f[V]...\f[R])
indicating functions using a variable number of arguments.
Its meaning is the same as in Lua.
It\[aq]s identified with \f[V]fennel.varg?\f[R] and constructed with
\f[V]fennel.varg\f[R].
.SS number/string/boolean
.PP
These are literal types defined by Lua.
They cannot carry source data.
.SS comment
.PP
By default, ASTs will omit comments.
However, when the \f[V]:comment\f[R] field is set in the parser options,
comments will be included in the parsed values.
They are identified using \f[V]fennel.comment?\f[R] and constructed
using the \f[V]fennel.comment\f[R] function.
They are represented as tables that have source data as fields inside
them.
.PP
In most data context, comments just get included inline in a list or
sequence.
However, in a kv table, this cannot be done, because kv tables must have
balanced key/value pairs, and including comments inline would imbalance
these or cause keys to be considered as values and vice versa.
So the comments are stored on the \f[V]comments\f[R] field of metatable
instead, keyed by the key or value they were attached to.
.SH SERIALIZATION (VIEW)
.PP
The \f[V]fennel.view\f[R] function takes any Fennel data and turns it
into a representation suitable for feeding back to Fennel\[aq]s parser.
In addition to tables, strings, numbers, and booleans, it can produce
reasonable output from ASTs that come from the parser.
It will emit an unreadable placeholder for coroutines, compiled
functions, and userdata, which cannot be understood by the parser.
.IP
.nf
\f[C]
print(fennel.view({abc=123}[, options])
{:abc 123}
\f[R]
.fi
.PP
The list of common options at the top of this document do not apply
here; instead these options are accepted:
.IP \[bu] 2
\f[V]one-line?\f[R] (default: false) keep the output string as a
one-liner
.IP \[bu] 2
\f[V]depth\f[R] (number, default: 128) limit how many levels to go
(default: 128)
.IP \[bu] 2
\f[V]detect-cycles?\f[R] (default: true) don\[aq]t try to traverse a
looping table
.IP \[bu] 2
\f[V]metamethod?\f[R] (default: true) use the __fennelview metamethod if
found
.IP \[bu] 2
\f[V]empty-as-sequence?\f[R] (default: false) render empty tables as []
.IP \[bu] 2
\f[V]line-length\f[R] (number, default: 80) length of the line at which
multi-line output for tables is forced
.IP \[bu] 2
\f[V]byte-escape\f[R] (function) If present, overrides default behavior
of escaping special characters in decimal format (e.g.
\f[V]<ESC>\f[R] -> \f[V]\[rs]027\f[R]).
Called with the signature \f[V](byte-escape byte view-opts)\f[R], where
byte is the char code for a special character
.IP \[bu] 2
\f[V]escape-newlines?\f[R] (default: false) emit strings with \[rs]n
instead of newline
.IP \[bu] 2
\f[V]prefer-colon?\f[R] (default: false) emit strings in colon notation
when possible
.IP \[bu] 2
\f[V]utf8?\f[R] (default true) whether to use utf8 module to compute
string lengths
.IP \[bu] 2
\f[V]max-sparse-gap\f[R] (integer, default 10) maximum gap to fill in
with nils in sparse sequential tables.
.IP \[bu] 2
\f[V]preprocess\f[R] (function) if present, called on x (and recursively
on each value in x), and the result is used for pretty printing; takes
the same arguments as \f[V]fennel.view\f[R]
.PP
All options can be set to \f[V]{:once some-value}\f[R] to force their
value to be \f[V]some-value\f[R] but only for the current level.
After that, such option is reset to its default value.
Alternatively, \f[V]{:once value :after other-value}\f[R] can be used,
with the difference that after first use, the options will be set to
\f[V]other-value\f[R] instead of the default value.
.PP
You can set a \f[V]__fennelview\f[R] metamethod on a table to override
its serialization behavior.
It should take the table being serialized as its first argument, a
function as its second argument, options table as third argument, and
current amount of indentation as its last argument:
.IP
.nf
\f[C]
(fn [t view options indent] ...)
\f[R]
.fi
.PP
\f[V]view\f[R] function contains a pretty printer that can be used to
serialize elements stored within the table being serialized.
If your metamethod produces indented representation, you should pass
\f[V]indent\f[R] parameter to \f[V]view\f[R] increased by the amount of
additional indentation you\[aq]ve introduced.
This function has the same interface as \f[V]__fennelview\f[R]
metamethod, but in addition accepts \f[V]colon-string?\f[R] as last
argument.
If \f[V]colon?\f[R] is \f[V]true\f[R], strings will be printed as
colon-strings when possible, and if its value is \f[V]false\f[R],
strings will be always printed in double quotes.
If omitted or \f[V]nil\f[R] will default to value of
\f[V]:prefer-colon?\f[R] option.
.PP
\f[V]options\f[R] table contains options described above, and also
\f[V]visible-cycle?\f[R] function, that takes a table being serialized,
detects and saves information about possible reachable cycle.
Should be used in \f[V]__fennelview\f[R] to implement cycle detection.
.PP
\f[V]__fennelview\f[R] metamethod should always return a table of
correctly indented lines when producing multi-line output, or a string
when always returning single-line item.
\f[V]fennel.view\f[R] will transform your data structure to correct
multi-line representation when needed.
There\[aq]s no need to concatenate table manually ever -
\f[V]fennel.view\f[R] will apply general rules for your data structure,
depending on current options.
By default multiline output is produced only when inner data structures
contains newlines, or when returning table of lines as single line
results in width greater than \f[V]line-size\f[R] option.
.PP
Multi-line representation can be forced by returning two values from
\f[V]__fennelview\f[R] - a table of indented lines as first value, and
\f[V]true\f[R] as second value, indicating that multi-line
representation should be forced.
.PP
There\[aq]s no need to incorporate indentation beyond needed to
correctly align elements within the printed representation of your data
structure.
For example, if you want to print a multi-line table, like this:
.IP
.nf
\f[C]
\[at]my-table[1
          2
          3]
\f[R]
.fi
.PP
\f[V]__fennelview\f[R] should return a sequence of lines:
.IP
.nf
\f[C]
[\[dq]\[at]my-table[1\[dq]
 \[dq]          2\[dq]
 \[dq]          3]\[dq]]
\f[R]
.fi
.PP
Note, since we\[aq]ve introduced inner indent string of length 10, when
calling \f[V]view\f[R] function from within \f[V]__fennelview\f[R]
metamethod, in order to keep inner tables indented correctly,
\f[V]indent\f[R] must be increased by this amount of extra indentation.
.PP
Here\[aq]s an implementation of such pretty-printer for an arbitrary
sequential table:
.IP
.nf
\f[C]
(fn pp-doc-example [t view options indent]
  (let [lines (icollect [i v (ipairs t)]
                (let [v (view v options (+ 10 indent))]
                  (if (= i 1) v
                      (.. \[dq]          \[dq] v))))]
    (doto lines
      (tset 1 (.. \[dq]\[at]my-table[\[dq] (or (. lines 1) \[dq]\[dq])))
      (tset (length lines) (.. (. lines (length lines)) \[dq]]\[dq])))))
\f[R]
.fi
.PP
Setting table\[aq]s \f[V]__fennelview\f[R] metamethod to this function
will provide correct results regardless of nesting:
.IP
.nf
\f[C]
>> {:my-table (setmetatable [[1 2 3 4 5]
                             {:smalls [6 7 8 9 10 11 12]
                              :bigs [500 1000 2000 3000 4000]}]
                            {:__fennelview pp-doc-example})
    :normal-table [{:c [1 2 3] :d :some-data} 4]}
{:my-table \[at]my-table[[1 2 3 4 5]
                     {:bigs [500 1000 2000 3000 4000]
                      :smalls [6 7 8 9 10 11 12]}]
 :normal-table [{:c [1 2 3] :d \[dq]some-data\[dq]} 4]}
\f[R]
.fi
.PP
Note that even though we\[aq]ve only indented inner elements of our
table with 10 spaces, the result is correctly indented in terms of outer
table, and inner tables also remain indented correctly.
.PP
When using the \f[V]:preprocess\f[R] option or \f[V]__fennelview\f[R]
method, avoid modifying any tables in-place in the passed function.
Since Lua tables are mutable and passed in without copying, any
modification done in these functions will be visible outside of
\f[V]fennel.view\f[R].
.PP
Using \f[V]:byte-escape\f[R] to override the special character escape
format is intended for use-cases where it\[aq]s known that the output
will be consumed by something other than Lua/Fennel, and may result in
output that Fennel can no longer parse.
For example, to force the use of hex escapes:
.IP
.nf
\f[C]
(print (fennel.view {:clear-screen \[dq]\[rs]027[H\[rs]027[2J\[dq]}
                    {:byte-escape #(: \[dq]\[rs]\[rs]x%2x\[dq] :format $)}))
;; > {:clear-screen \[dq]\[rs]x1b[H\[rs]x1b[2J\[dq]}
\f[R]
.fi
.PP
While Lua 5.2+ supports hex escapes, PUC Lua 5.1 does not, so compiling
this with Fennel later would result in an incorrect escape code in Lua
5.1.
.SH WORK WITH DOCSTRINGS AND METADATA
.PP
\f[I](Since 0.3.0)\f[R]
.PP
When running a REPL or using compile/eval with metadata enabled, each
function declared with \f[V]fn\f[R] or \f[V]λ/lambda\f[R] will use the
created function as a key on \f[V]fennel.metadata\f[R] to store the
function\[aq]s arglist and (if provided) docstring.
The metadata table is weakly-referenced by key, so each function\[aq]s
metadata will be garbage collected along with the function itself.
.PP
You can work with the API to view or modify this metadata yourself, or
use the \f[V],doc\f[R] repl command to view function documentation.
.PP
In addition to direct access to the metadata tables, you can use the
following methods:
.IP \[bu] 2
\f[V]fennel.metadata:get(func, key)\f[R]: get a value from a
function\[aq]s metadata
.IP \[bu] 2
\f[V]fennel.metadata:set(func, key, val)\f[R]: set a metadata value
.IP \[bu] 2
\f[V]fennel.metadata:setall(func, key1, val1, key2, val2, ...)\f[R]: set
pairs
.IP \[bu] 2
\f[V]fennel.doc(func, fnName)\f[R]: print formatted documentation for
function using name.
Utilized by the \f[V],doc\f[R] command, name is whatever symbol you
operate on that\[aq]s bound to the function.
.IP
.nf
\f[C]
local greet = fennel.eval(\[aq](λ greet [name] \[dq]Say hello\[dq] (print \[dq]Hello,\[dq] name))\[aq],
                          {useMetadata = true})

fennel.metadata[greet]
-- > {\[dq]fnl/docstring\[dq] = \[dq]Say hello\[dq], \[dq]fnl/arglist\[dq] = [\[dq]name\[dq]]}

fennel.doc(greet, \[dq]greet\[dq])
-- > (greet name)
-- >   Say hello

fennel.metadata:set(greet, \[dq]fnl/docstring\[dq], \[dq]Say hello!!!\[dq])
fennel.doc(greet, \[dq]greet!\[dq])
--> (greet! name)
-->   Say hello!!!
\f[R]
.fi
.SS Metadata performance note
.PP
Enabling metadata in the compiler/eval/REPL will cause every function to
store a new table containing the function\[aq]s arglist and docstring in
the metadata table, weakly referenced by the function itself as a key.
.PP
This may have a performance impact in some applications due to the extra
allocations and garbage collection associated with dynamic function
creation.
The impact hasn\[aq]t been benchmarked, but enabling metadata is
currently recommended for development purposes only.
.SH DESCRIBE FENNEL SYNTAX
.PP
If you\[aq]re writing a tool which performs syntax highlighting or some
other operations on Fennel code, the \f[V]fennel.syntax\f[R] function
can provide you with data about what forms and keywords to treat
specially.
.IP
.nf
\f[C]
local syntax = fennel.syntax()
print(fennel.view(syntax[\[dq]icollect\[dq]]))
--> {:binding-form? true :body-form? true :macro? true}
\f[R]
.fi
.PP
The table has string keys and table values.
Each entry will have one of \f[V]\[dq]macro?\[dq]\f[R],
\f[V]\[dq]global?\[dq]\f[R], or \f[V]\[dq]special?\[dq]\f[R] set to
\f[V]true\f[R] indicating what type it is.
Globals can also have \f[V]\[dq]function?\[dq]\f[R] set to true.
Macros and specials can have \f[V]\[dq]binding-form?\[dq]\f[R] set to
true indicating it accepts a \f[V][]\f[R] argument which introduces new
locals, and/or a \f[V]\[dq]body-form?\[dq]\f[R] indicating whether it
should be indented with two spaces instead of being indented like a
function call.
They can also have a \f[V]\[dq]define?\[dq]\f[R] key indicating whether
it introduces a new top-level identifier like \f[V]local\f[R] or
\f[V]fn\f[R].
.SH LOAD LUA CODE IN A PORTABLE WAY
.PP
This isn\[aq]t Fennel-specific, but the \f[V]loadCode\f[R] function
takes a string of Lua code along with an optional environment table and
filename string, and returns a function for the loaded code which will
run inside that environment, in a way that\[aq]s portable across any Lua
5.1+ version.
.IP
.nf
\f[C]
local f = fennel.loadCode(luaCode, { x = y }, \[dq]myfile.lua\[dq])
\f[R]
.fi
.SH DETECT LUA VM RUNTIME VERSION
.PP
This function does a best effort detection of the Lua VM environment
hosting Fennel.
Useful for displaying an \[dq]About\[dq] dialog in your Fennel app that
matches the REPL and \f[V]--version\f[R] CLI flag.
.IP
.nf
\f[C]
(fennel.runtime-version)
\f[R]
.fi
.IP
.nf
\f[C]
print(fennel.runtimeVersion())
-- > Fennel 1.0.0 on PUC Lua 5.4
\f[R]
.fi
.PP
The \f[V]fennel.version\f[R] field will give you the version of just
Fennel itself.
.PP
\f[I](since 1.3.1)\f[R]
.PP
If an optional argument is given, returns version information as a
table:
.IP
.nf
\f[C]
(fennel.runtime-version :as-table)
;; > {:fennel \[dq]1.3.1\[dq] :lua \[dq]PUC Lua 5.4\[dq]}
\f[R]
.fi
.SH PLUGINS
.PP
Fennel\[aq]s plugin system is extremely experimental and exposes
internals of the compiler in ways that no other part of the compiler
does.
It should be considered unstable; changes to the compiler in future
versions are likely to break plugins, and each plugin should only be
assumed to work with specific versions of the compiler that they\[aq]re
tested against.
The backwards-compatibility guarantees of the rest of Fennel \f[B]do not
apply\f[R] to plugins.
.PP
Compiler plugins allow the functionality of the compiler to be extended
in various ways.
A plugin is a module containing various functions in fields named after
different compiler extension points.
When the compiler hits an extension point, it will call each
plugin\[aq]s function for that extension point, if provided, with
various arguments; usually the AST in question and the scope table.
Each plugin function should normally do side effects and return nil or
error out.
If a function returns non-nil, it will cause the rest of the plugins for
a given event to be skipped.
.IP \[bu] 2
\f[V]symbol-to-expression\f[R]
.IP \[bu] 2
\f[V]call\f[R]
.IP \[bu] 2
\f[V]do\f[R]
.IP \[bu] 2
\f[V]fn\f[R]
.IP \[bu] 2
\f[V]destructure\f[R]
.IP \[bu] 2
\f[V]parse-error\f[R]
.IP \[bu] 2
\f[V]assert-compile\f[R]
.PP
The \f[V]destructure\f[R] extension point is different because instead
of just taking \f[V]ast\f[R] and \f[V]scope\f[R] it takes a
\f[V]from\f[R] which is the AST for the value being destructured and a
\f[V]to\f[R] AST which is the AST for the form being destructured to.
This is most commonly a symbol but can be a list or a table.
.PP
The \f[V]parse-error\f[R] and \f[V]assert-compile\f[R] hooks can be used
to override how fennel behaves down to the parser and compiler levels.
Possible use-cases include building atop \f[V]fennel.view\f[R] to
serialize data with
EDN (https://clojure.github.io/clojure/clojure.edn-api.html)-style
tagging, or manipulating external s-expression-based syntax, such as
tree-sitter
queries (https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax).
.PP
The \f[V]scope\f[R] argument is a table containing all the
compiler\[aq]s information about the current scope.
Most of the tables here look up values in their parent scopes if they do
not contain a key.
.PP
Plugins can also contain repl commands.
If your plugin module has a field with a name beginning with
\[dq]repl-command-\[dq] then that function will be available as a comma
command from within a repl session.
It will be called with a table for the repl session\[aq]s environment, a
function which will read the next form from stdin, a function which is
used to print normal values, and one which is used to print errors.
.IP
.nf
\f[C]
(local fennel (require :fennel)
(fn locals [env read on-values on-error scope]
  \[dq]Print all locals in repl session scope.\[dq]
  (on-values [(fennel.view env.___replLocals___)]))

{:repl-command-locals locals}
\f[R]
.fi
.IP
.nf
\f[C]
$ fennel --plugin locals-plugin.fnl
Welcome to Fennel 0.8.0 on Lua 5.4!
Use ,help to see available commands.
>> (local x 4)
nil
>> (local abc :xyz)
nil
>> ,locals
{
  :abc \[dq]xyz\[dq]
  :x 4
}
\f[R]
.fi
.PP
The docstring of the function will be used as its summary in the
\[dq],help\[dq] command listing.
Unlike other plugin hook fields, only the first plugin to provide a repl
command will be used.
.SS Activation
.PP
Plugins are activated by passing the \f[V]--plugin\f[R] argument on the
command line, which should be a path to a Fennel file containing a
module that has some of the functions listed above.
If you\[aq]re using the compiler programmatically, you can include a
\f[V]:plugins\f[R] table in the \f[V]options\f[R] table to most compiler
entry point functions.
.PP
Your plugin should contain a \f[V]:versions\f[R] table which contains a
list of strings indicating every version of Fennel which you have tested
it with.
You should also have a \f[V]:name\f[R] field with the plugin\[aq]s name.
.SH AUTHORS
Fennel Maintainers.
