.\" Automatically generated by Pandoc 3.1.11.1
.\"
.TH "fennel\-api" "3" "2025\-03\-28" "fennel 1.5.4-dev" "Fennel\[aq]s Lua API"
.SH NAME
fennel\-api \- Fennel\[aq]s Lua API
.SH DESCRIPTION
The \f[CR]fennel\f[R] module provides the following functions for use
when embedding Fennel in a Lua program.
If you\[aq]re writing a pure Fennel program or working on a system that
already has Fennel support, you probably don\[aq]t need this.
.PP
Only the \f[CR]fennel\f[R] module is part of the public API.
The other modules are implementation details subject to change.
Most functions will \f[CR]error\f[R] upon failure.
.PP
Any time a function takes an \f[CR]options\f[R] table argument, that
table will usually accept these fields:
.IP \[bu] 2
\f[CR]allowedGlobals\f[R]: a sequential table of strings of the names of
globals which the compiler will allow references to.
Set to false to disable checks.
Defaults to the contents of the \f[CR]env\f[R] table, if provided, or
the current environment.
.IP \[bu] 2
\f[CR]correlate\f[R]: when this is set, Fennel attempts to emit Lua
where the line numbers match up with the Fennel input code; useful for
situation where code that isn\[aq]t under your control will print the
stack traces.
This is meant as a debugging aid and cannot give exact numbers in all
cases.
.IP \[bu] 2
\f[CR]useMetadata\f[R]: enables or disables metadata, allowing use of
the \f[CR],doc\f[R] repl command.
Intended for development purposes (see performance note); defaults to
true for REPL only.
.IP \[bu] 2
\f[CR]requireAsInclude\f[R]: Alias any static \f[CR]require\f[R] calls
to the \f[CR]include\f[R] special, embedding the module code inline in
the compiled output.
If the module name isn\[aq]t a string literal that is resolvable at
compile time it falls back to \f[CR]require\f[R] at runtime.
Can be used to embed both Fennel and Lua modules.
.IP \[bu] 2
\f[CR]assertAsRepl\f[R]: Replace calls to \f[CR]assert\f[R] with
\f[CR]assert\-repl\f[R] to allow for interactive debugging.
.IP \[bu] 2
\f[CR]env\f[R]: an environment table in which to run the code; see the
Lua manual.
.IP \[bu] 2
\f[CR]compilerEnv\f[R]: an environment table in which to run
compiler\-scoped code for macro definitions and
\f[CR]eval\-compiler\f[R] calls.
Internal Fennel functions such as \f[CR]list\f[R], \f[CR]sym\f[R], etc.
will be exposed in addition to this table.
Defaults to a table containing limited known\-safe globals.
Pass \f[CR]_G\f[R] to disable sandboxing.
.IP \[bu] 2
\f[CR]unfriendly\f[R]: disable friendly compiler/parser error messages.
.IP \[bu] 2
\f[CR]plugins\f[R]: list of compiler plugins.
.IP \[bu] 2
\f[CR]error\-pinpoint\f[R]: a list of two strings indicating what to
wrap compile errors in
.IP \[bu] 2
\f[CR]keywords\f[R]: a table of the form
\f[CR]{:keyword1 true :keyword2 true}\f[R] containing symbols that
should be treated as reserved Lua keywords.
.IP \[bu] 2
\f[CR]global\-mangle\f[R]: whether to mangle globals in compiler output;
set to \f[CR]false\f[R] to turn global references that aren\[aq]t valid
Lua into \f[CR]_G[\[aq]hello\-world\[aq]]\f[R].
.PP
You can pass the string \f[CR]\[dq]_COMPILER\[dq]\f[R] as the value for
\f[CR]env\f[R]; it will cause the code to be run/compiled in a context
which has all compiler\-scoped values available.
This can be useful for macro modules or compiler plugins.
If you want to add additional values to the environment in this case,
you can use the \f[CR]extra\-env\f[R] key.
.PP
Note that only the \f[CR]fennel\f[R] module is part of the public API.
The other modules (\f[CR]fennel.utils\f[R], \f[CR]fennel.compiler\f[R],
etc) should be considered compiler internals subject to change.
.PP
If you are embedding Fennel in a context where ANSI escape codes are not
interpreted, you can set \f[CR]error\-pinpoint\f[R] to \f[CR]false\f[R]
to disable the highlighting of compiler and parse errors.
.SH START A CONFIGURABLE REPL
.IP
.EX
fennel.repl([options])
.EE
.PP
Takes these additional options:
.IP \[bu] 2
\f[CR]readChunk(state)\f[R]: a function that when called, returns a line
of code to run.
This can be an incomplete expression, in which case it will be called
again until a complete expression can be constructed.
The state argument is a table with a \f[CR]stack\-size\f[R] field which
will be zero unless it\[aq]s reading a continuation of previous input.
Strings returned should end in newlines.
It should return nil when there is no more source, which will exit the
repl.
.IP \[bu] 2
\f[CR]onValues(values)\f[R]: a function which is called for every
evaluation with a sequence table containing string representations of
each of the values resulting from the input.
.IP \[bu] 2
\f[CR]onError(errType, err, luaSource)\f[R]: a function that will be
called on each error.
\f[CR]errType\f[R] is a string with the type of error: \[aq]parse\[aq],
\[aq]compile\[aq], \[aq]runtime\[aq], or \[aq]lua\[aq].
\f[CR]err\f[R] is the error message, and \f[CR]luaSource\f[R] is the
source of the generated lua code.
.IP \[bu] 2
\f[CR]pp(x)\f[R]: a pretty\-printer function to apply on values
(default: \f[CR]fennel.view\f[R]).
.IP \[bu] 2
\f[CR]view\-opts\f[R]: an options table passed to \f[CR]pp\f[R]
(default: \f[CR]{:depth 4}\f[R]).
.IP \[bu] 2
\f[CR]rawValues(...)\f[R]: a function which is passed the raw values
from evaluation; like \f[CR]onValues\f[R] but receives the underlying
data rather than the string representation.
.PP
Note that overriding \f[CR]readChunk\f[R]/\f[CR]onValues\f[R] will only
affect input and output initiated by the repl directly.
If the repl runs code that calls \f[CR]print\f[R], \f[CR]io.write\f[R],
\f[CR]io.read\f[R], etc, those will still use stdio unless overridden in
\f[CR]env\f[R].
.PP
By default, metadata will be enabled and you can view function
signatures and docstrings with the \f[CR],doc\f[R] command in the REPL.
.PP
In Fennel 1.4.1 \f[CR]fennel.repl\f[R] was changed from a normal
function to a callable table.
This mostly behaves the same, but it can cause problems with certain
functions that are very picky about functions.
Unfortunately this includes \f[CR]coroutine.create\f[R].
You can pass \f[CR]fennel.repl.repl\f[R] instead.
.SS Customize REPL default options
Any fields set on \f[CR]fennel.repl\f[R], which is actually a table with
a \f[CR]__call\f[R] metamethod rather than a function, will used as a
fallback for any options passed to \f[CR](fennel.repl)\f[R] before
defaults are applied, allowing one to
.PP
customize the default behavior of \f[CR](fennel.repl)\f[R]:
.IP
.EX
fennel.repl.onError = custom_error_handler
\-\- In rare cases this needs to be temporary, overrides
\-\- can be cleared by simply clearing the entire table
for k in pairs(fennel.repl) do
  fennel.repl[k] = nil
end
.EE
.SH EVALUATE A STRING OF FENNEL
.IP
.EX
local result = fennel.eval(str[, options[, ...]])
.EE
.PP
The \f[CR]options\f[R] table may also contain:
.IP \[bu] 2
\f[CR]filename\f[R]: override the filename that Lua thinks the code came
from.
.PP
Additional arguments beyond \f[CR]options\f[R] are passed to the code
and available as \f[CR]...\f[R].
.SH EVALUATE A FILE OF FENNEL
.IP
.EX
local result = fennel.dofile(filename[, options[, ...]])
.EE
.PP
Additional arguments beyond \f[CR]options\f[R] are passed to the code
and available as \f[CR]...\f[R].
.SH USE LUA\[aq]S BUILT\-IN REQUIRE FUNCTION
.IP
.EX
require(\[dq]fennel\[dq]).install().dofile(\[dq]main.fnl\[dq])
.EE
.PP
This is the equivalent of this code:
.IP
.EX
local fennel = require(\[dq]fennel\[dq])
table.insert(package.loaders or package.searchers, fennel.searcher)
fennel.dofile(\[dq]main.fnl\[dq]) \-\- require calls in main.fnl can load fennel modules
.EE
.PP
Normally Lua\[aq]s \f[CR]require\f[R] function only loads modules
written in Lua, but you can install \f[CR]fennel.searcher\f[R] into
\f[CR]package.searchers\f[R] (or in Lua 5.1 \f[CR]package.loaders\f[R])
to teach it how to load Fennel code.
.PP
If you would rather change some of the options you can use
\f[CR]fennel.makeSearcher(options)\f[R] to get a searcher function
that\[aq]s equivalent to \f[CR]fennel.searcher\f[R] but overrides the
default \f[CR]options\f[R] table.
.PP
The \f[CR]require\f[R] function is different from
\f[CR]fennel.dofile\f[R] in that it searches the directories in
\f[CR]fennel.path\f[R] for \f[CR].fnl\f[R] files matching the module
name, and also in that it caches the loaded value to return on
subsequent calls, while \f[CR]fennel.dofile\f[R] will reload each time.
The behavior of \f[CR]fennel.path\f[R] mirrors that of Lua\[aq]s
\f[CR]package.path\f[R].
There is also a \f[CR]fennel.macro\-path\f[R] which is used to look up
macro modules.
.PP
If you install Fennel into \f[CR]package.searchers\f[R] then you can use
the repl\[aq]s \f[CR],reload mod\f[R] command to reload modules that
have been loaded with \f[CR]require\f[R].
.SH MACRO SEARCHERS
The compiler sandbox makes it so that the module system is also isolated
from the rest of the system, so the above \f[CR]require\f[R] calls will
not work from inside macros.
However, there is a separate \f[CR]fennel.macro\-searchers\f[R] table
which can be used to allow different modules to be loaded inside macros.
By default it includes a searcher to load sandboxed Fennel modules and a
searcher to load sandboxed Lua modules, but if you disable the compiler
sandbox you may want to replace these with searchers which can load
arbitrary modules.
.PP
The default \f[CR]fennel.macro\-searchers\f[R] functions also cannot
load C modules.
Here\[aq]s an example of some code which would allow that to work:
.IP
.EX
table.insert(fennel[\[dq]macro\-searchers\[dq]], function(module_name)
  local filename = fennel[\[dq]search\-module\[dq]](module_name, package.cpath)
  if filename then
    local func = \[dq]luaopen_\[dq] .. module_name
    return function() return package.loadlib(filename, func) end, filename
  end
end)
.EE
.PP
Macro searchers store loaded macro modules in the
\f[CR]fennel.macro\-loaded\f[R] table which works the same as
\f[CR]package.loaded\f[R] but for macro modules.
.SH GET FENNEL\-AWARE STACK INFORMATION
The \f[CR]fennel.traceback\f[R] function works like Lua\[aq]s
\f[CR]debug.traceback\f[R] function, except it tracks line numbers from
Fennel code correctly.
.PP
If you are working on an application written in Fennel, you can override
the default traceback function to replace it with Fennel\[aq]s:
.IP
.EX
debug.traceback = fennel.traceback
.EE
.PP
Note that some systems print stack traces from C, which will not be
affected.
.PP
The \f[CR]fennel.getinfo\f[R] function works like Lua\[aq]s
\f[CR]debug.getinfo\f[R] function, except it tracks line numbers from
Fennel code correctly.
Functions defined from Fennel will have the \f[CR]what\f[R] field set to
\f[CR]\[dq]Fennel\[dq]\f[R] instead of \f[CR]\[dq]Lua\[dq]\f[R].
.IP
.EX
local mymodule = require(\[dq]module\[dq])
print(fennel.getinfo(mymodule.func1).linedefined)
.EE
.SH COMPILE FENNEL CODE TO LUA
.SS Compile a file, AST, or byte iterator
.IP
.EX
local lua = fennel.compile(fennelSource[, options])
.EE
.PP
The first argument here can be a file name, an AST (usually produced by
\f[CR]fennel.parser\f[R]), or a stateful iterator function of bytes.
.PP
Unlike the other functions, the \f[CR]compile\f[R] functions default to
performing no global checks, though you can pass in an
\f[CR]allowedGlobals\f[R] table in \f[CR]options\f[R] to enable it.
Accepts \f[CR]filename\f[R] in \f[CR]options\f[R] like
\f[CR]fennel.eval\f[R] for error reporting purposes.
.SS Compile a string of Fennel code
.IP
.EX
local lua = fennel.compileString(fennelcode[, options])
.EE
.PP
Also aliased to \f[CR]fennel.compile\-string\f[R] for convenience
calling from Fennel.
.SH PARSE TEXT INTO AST NODES
The \f[CR]fennel.parser\f[R] function returns a function which you can
call repeatedly to get successive AST nodes from a string.
This happens to be an iterator function, so you can use it with
Lua\[aq]s \f[CR]for\f[R] or Fennel\[aq]s \f[CR]each\f[R].
If a form was successfully read, it returns true followed by the AST
node.
Returns nil when it reaches the end.
Raises an error if it can\[aq]t parse the input.
.IP
.EX
local parse = fennel.parser(text)
local ok, ast = assert(parse()) \-\- just get the first form

\-\- Or use in a for loop
for ok, ast in parse do
  if ok then
    print(fennel.view(ast))
  end
end
.EE
.PP
The first argument can either be a string or a function that returns one
byte at a time.
It takes two optional arguments; a filename and a table of options.
Supported options are both booleans that default to false:
.IP \[bu] 2
\f[CR]unfriendly\f[R]: disable enhanced parse error reporting
.IP \[bu] 2
\f[CR]comments\f[R]: include comment nodes in AST
.IP \[bu] 2
\f[CR]plugins\f[R]: \f[I](since 1.2.0)\f[R] An optional list of compiler
plugins.
.PP
The list of common options at the top of this document do not apply
here.
.SH AST NODE DEFINITION
The AST returned by the parser consists of data structures representing
the code.
Passing AST nodes to the \f[CR]fennel.view\f[R] function will give you a
string which should round\-trip thru the parser to give you the same
data back.
The same is true with \f[CR]tostring\f[R], except it does not work with
non\-sequence tables.
.PP
The \f[CR]fennel.ast\-source\f[R] function takes an AST node and returns
a table with source data around filename, line number, et in it, if
possible.
Some AST nodes cannot provide this data, for instance numbers, strings,
and booleans, or symbols constructed within macros using the
\f[CR]sym\f[R] function instead of backtick.
.PP
AST nodes can be any of these types:
.SS list
A list represents a call to function/macro, or destructuring multiple
return values in a binding context.
It\[aq]s represented as a table which can be identified using the
\f[CR]fennel.list?\f[R] predicate function or constructed using
\f[CR]fennel.list\f[R] which takes any number of arguments for the
contents of the list.
.PP
Note that lists are compile\-time constructs in Fennel.
They do not exist at runtime, except in such cases as the compiler is in
use at runtime.
.PP
The list also contains these keys indicating where it was defined:
\f[CR]filename\f[R], \f[CR]line\f[R], \f[CR]col\f[R], \f[CR]endcol\f[R],
\f[CR]bytestart\f[R], and \f[CR]byteend\f[R].
This data is used for stack traces and for pinpointing compiler error
messages.
Note that column numbers are based on character count, which does not
always correspond to visual columns; for instance \[dq]วัด\[dq] is three
characters but only two visual columns.
.SS sequence/key\-value table
These are table literals in Fennel code produced by square brackets
(sequences) or curly brackets (k/v tables).
Sequences can be identified using the \f[CR]fennel.sequence?\f[R]
function and constructed using \f[CR]fennel.sequence\f[R].
There is no predicate or constructor for k/v tables; any table which is
not one of the other types is assumed to be one of these.
.PP
At runtime there is no difference between sequences and k/v tables which
use monotonically increasing integer keys, but the parser is able to
distinguish between them to improve error reporting.
.PP
Sequences and k/v tables have their source data in \f[CR]filename\f[R],
\f[CR]line\f[R], etc keys of their metatable.
The metatable for k/v tables also includes a \f[CR]keys\f[R] sequence
which tells you which order the keys appeared originally, since k/v
tables are unordered and there would otherwise be no way to reconstruct
this information.
.SS symbol
Symbols typically represent identifiers in Fennel code.
Symbols can be identified with \f[CR]fennel.sym?\f[R] and constructed
with \f[CR]fennel.sym\f[R] which takes a string name as its first
argument and a source data table as the second.
Symbols are represented as tables which store their source data
(\f[CR]filename\f[R], \f[CR]line\f[R], \f[CR]col\f[R], etc) in fields on
themselves.
Unlike the other tables in the AST, they do not represent collections;
they are used as scalar types.
.PP
Symbols can refer not just directly to locals, but also to table
references like \f[CR]tbl.x\f[R] for field lookup or
\f[CR]access.channel:deny\f[R] for method invocation.
The \f[CR]fennel.multi\-sym?\f[R] function will return a table
containing the segments if the symbol if it is one of these, or nil
otherwise.
.PP
\f[B]Note:\f[R] \f[CR]nil\f[R] is not a valid AST; code that references
nil will have the symbol named \f[CR]\[dq]nil\[dq]\f[R] which
unfortunately prints in a way that is visually indistinguishable from
actual \f[CR]nil\f[R].
.PP
The \f[CR]fennel.sym\-char?\f[R] function will tell you if a given
character is allowed to be used in the name of a symbol.
.SS vararg
This is a special type of symbol\-like construct (\f[CR]...\f[R])
indicating functions using a variable number of arguments.
Its meaning is the same as in Lua.
It\[aq]s identified with \f[CR]fennel.varg?\f[R] and constructed with
\f[CR]fennel.varg\f[R].
.SS number/string/boolean
These are literal types defined by Lua.
They cannot carry source data.
.SS comment
By default, ASTs will omit comments.
However, when the \f[CR]:comment\f[R] field is set in the parser
options, comments will be included in the parsed values.
They are identified using \f[CR]fennel.comment?\f[R] and constructed
using the \f[CR]fennel.comment\f[R] function.
They are represented as tables that have source data as fields inside
them.
.PP
In most data contexts, comments just get included inline in a list or
sequence.
However, in a k/v table, this cannot be done, because k/v tables must
have balanced key/value pairs, and including comments inline would
imbalance these or cause keys to be considered as values and vice versa.
So the comments are stored on the \f[CR]comments\f[R] field of metatable
instead, keyed by the key or value they were attached to.
.SH SEARCH THE PATH FOR A MODULE WITHOUT LOADING IT
.IP
.EX
print(fennel.searchModule(\[dq]my.mod\[dq], package.path))
.EE
.PP
If you just want to find the file path that a module would resolve to
without actually loading it, you can use \f[CR]fennel.searchModule\f[R].
The first argument is the module name, and the second argument is the
path string to search.
If none is provided, it defaults to Fennel\[aq]s own path.
.PP
Returns \f[CR]nil\f[R] if the module is not found on the path.
.SH SERIALIZATION (VIEW)
The \f[CR]fennel.view\f[R] function takes any Fennel data and turns it
into a representation suitable for feeding back to Fennel\[aq]s parser.
In addition to tables, strings, numbers, and booleans, it can produce
reasonable output from ASTs that come from the parser.
It will emit an unreadable placeholder for coroutines, compiled
functions, and userdata, which cannot be understood by the parser.
.IP
.EX
print(fennel.view({abc=123}[, options])
{:abc 123}
.EE
.PP
The list of common options at the top of this document do not apply
here; instead these options are accepted:
.IP \[bu] 2
\f[CR]one\-line?\f[R] (default: false) keep the output string as a
one\-liner
.IP \[bu] 2
\f[CR]depth\f[R] (number, default: 128) limit how many levels to go
(default: 128)
.IP \[bu] 2
\f[CR]detect\-cycles?\f[R] (default: true) don\[aq]t try to traverse a
looping table
.IP \[bu] 2
\f[CR]metamethod?\f[R] (default: true) use the __fennelview metamethod
if found
.IP \[bu] 2
\f[CR]empty\-as\-sequence?\f[R] (default: false) render empty tables as
[]
.IP \[bu] 2
\f[CR]line\-length\f[R] (number, default: 80) length of the line at
which multi\-line output for tables is forced
.IP \[bu] 2
\f[CR]byte\-escape\f[R] (function) If present, overrides default
behavior of escaping special characters in decimal format (e.g.
\f[CR]<ESC>\f[R] \-> \f[CR]\[rs]027\f[R]).
Called with the signature \f[CR](byte\-escape byte view\-opts)\f[R],
where byte is the char code for a special character
.IP \[bu] 2
\f[CR]escape\-newlines?\f[R] (default: false) emit strings with \[rs]n
instead of newline
.IP \[bu] 2
\f[CR]prefer\-colon?\f[R] (default: false) emit strings in colon
notation when possible
.IP \[bu] 2
\f[CR]utf8?\f[R] (default: true) whether to use utf8 module to compute
string lengths
.IP \[bu] 2
\f[CR]max\-sparse\-gap\f[R] (number, default: 1) maximum gap to fill in
with nils in sparse sequential tables before switching to curly
brackets.
.IP \[bu] 2
\f[CR]preprocess\f[R] (function) if present, called on x (and
recursively on each value in x), and the result is used for pretty
printing; takes the same arguments as \f[CR]fennel.view\f[R]
.PP
All options can be set to \f[CR]{:once some\-value}\f[R] to force their
value to be \f[CR]some\-value\f[R] but only for the current level.
After that, such option is reset to its default value.
Alternatively, \f[CR]{:once value :after other\-value}\f[R] can be used,
with the difference that after first use, the options will be set to
\f[CR]other\-value\f[R] instead of the default value.
.PP
You can set a \f[CR]__fennelview\f[R] metamethod on a table to override
its serialization behavior.
It should take the table being serialized as its first argument, a
function as its second argument, options table as third argument, and
current amount of indentation as its last argument:
.IP
.EX
(fn [t view options indent] ...)
.EE
.PP
\f[CR]view\f[R] function contains a pretty printer that can be used to
serialize elements stored within the table being serialized.
If your metamethod produces indented representation, you should pass
\f[CR]indent\f[R] parameter to \f[CR]view\f[R] increased by the amount
of additional indentation you\[aq]ve introduced.
This function has the same interface as \f[CR]__fennelview\f[R]
metamethod, but in addition accepts \f[CR]colon\-string?\f[R] as last
argument.
If \f[CR]colon?\f[R] is \f[CR]true\f[R], strings will be printed as
colon\-strings when possible, and if its value is \f[CR]false\f[R],
strings will be always printed in double quotes.
If omitted or \f[CR]nil\f[R] will default to value of
\f[CR]:prefer\-colon?\f[R] option.
.PP
\f[CR]options\f[R] table contains options described above, and also
\f[CR]visible\-cycle?\f[R] function, that takes a table being
serialized, detects and saves information about possible reachable
cycle.
Should be used in \f[CR]__fennelview\f[R] to implement cycle detection.
.PP
\f[CR]__fennelview\f[R] metamethod should always return a table of
correctly indented lines when producing multi\-line output, or a string
when always returning single\-line item.
\f[CR]fennel.view\f[R] will transform your data structure to correct
multi\-line representation when needed.
There\[aq]s no need to concatenate table manually ever \-
\f[CR]fennel.view\f[R] will apply general rules for your data structure,
depending on current options.
By default multiline output is produced only when inner data structures
contains newlines, or when returning table of lines as single line
results in width greater than \f[CR]line\-size\f[R] option.
.PP
Multi\-line representation can be forced by returning two values from
\f[CR]__fennelview\f[R] \- a table of indented lines as first value, and
\f[CR]true\f[R] as second value, indicating that multi\-line
representation should be forced.
.PP
There\[aq]s no need to incorporate indentation beyond needed to
correctly align elements within the printed representation of your data
structure.
For example, if you want to print a multi\-line table, like this:
.IP
.EX
\[at]my\-table[1
          2
          3]
.EE
.PP
\f[CR]__fennelview\f[R] should return a sequence of lines:
.IP
.EX
[\[dq]\[at]my\-table[1\[dq]
 \[dq]          2\[dq]
 \[dq]          3]\[dq]]
.EE
.PP
Note, since we\[aq]ve introduced inner indent string of length 10, when
calling \f[CR]view\f[R] function from within \f[CR]__fennelview\f[R]
metamethod, in order to keep inner tables indented correctly,
\f[CR]indent\f[R] must be increased by this amount of extra indentation.
.PP
Here\[aq]s an implementation of such pretty\-printer for an arbitrary
sequential table:
.IP
.EX
(fn pp\-doc\-example [t view options indent]
  (let [lines (icollect [i v (ipairs t)]
                (let [v (view v options (+ 10 indent))]
                  (if (= i 1) v
                      (.. \[dq]          \[dq] v))))]
    (doto lines
      (tset 1 (.. \[dq]\[at]my\-table[\[dq] (or (. lines 1) \[dq]\[dq])))
      (tset (length lines) (.. (. lines (length lines)) \[dq]]\[dq])))))
.EE
.PP
Setting table\[aq]s \f[CR]__fennelview\f[R] metamethod to this function
will provide correct results regardless of nesting:
.IP
.EX
>> {:my\-table (setmetatable [[1 2 3 4 5]
                             {:smalls [6 7 8 9 10 11 12]
                              :bigs [500 1000 2000 3000 4000]}]
                            {:__fennelview pp\-doc\-example})
    :normal\-table [{:c [1 2 3] :d :some\-data} 4]}
{:my\-table \[at]my\-table[[1 2 3 4 5]
                     {:bigs [500 1000 2000 3000 4000]
                      :smalls [6 7 8 9 10 11 12]}]
 :normal\-table [{:c [1 2 3] :d \[dq]some\-data\[dq]} 4]}
.EE
.PP
Note that even though we\[aq]ve only indented inner elements of our
table with 10 spaces, the result is correctly indented in terms of outer
table, and inner tables also remain indented correctly.
.PP
When using the \f[CR]:preprocess\f[R] option or \f[CR]__fennelview\f[R]
method, avoid modifying any tables in\-place in the passed function.
Since Lua tables are mutable and passed in without copying, any
modification done in these functions will be visible outside of
\f[CR]fennel.view\f[R].
.PP
Using \f[CR]:byte\-escape\f[R] to override the special character escape
format is intended for use\-cases where it\[aq]s known that the output
will be consumed by something other than Lua/Fennel, and may result in
output that Fennel can no longer parse.
For example, to force the use of hex escapes:
.IP
.EX
(print (fennel.view {:clear\-screen \[dq]\[rs]027[H\[rs]027[2J\[dq]}
                    {:byte\-escape #(: \[dq]\[rs]\[rs]x%2x\[dq] :format $)}))
;; > {:clear\-screen \[dq]\[rs]x1b[H\[rs]x1b[2J\[dq]}
.EE
.PP
While Lua 5.2+ supports hex escapes, PUC Lua 5.1 does not, so compiling
this with Fennel later would result in an incorrect escape code in Lua
5.1.
.SH WORK WITH DOCSTRINGS AND METADATA
When running a REPL or using compile/eval with metadata enabled, each
function declared with \f[CR]fn\f[R] or \f[CR]λ/lambda\f[R] will use the
created function as a key on \f[CR]fennel.metadata\f[R] to store the
function\[aq]s arglist and (if provided) docstring.
The metadata table is weakly\-referenced by key, so each function\[aq]s
metadata will be garbage collected along with the function itself.
.PP
You can work with the API to view or modify this metadata yourself, or
use the \f[CR],doc\f[R] repl command to view function documentation.
.PP
In addition to direct access to the metadata tables, you can use the
following methods:
.IP \[bu] 2
\f[CR]fennel.metadata:get(func, key)\f[R]: get a value from a
function\[aq]s metadata
.IP \[bu] 2
\f[CR]fennel.metadata:set(func, key, val)\f[R]: set a metadata value
.IP \[bu] 2
\f[CR]fennel.metadata:setall(func, key1, val1, key2, val2, ...)\f[R]:
set pairs
.IP \[bu] 2
\f[CR]fennel.doc(func, fnName)\f[R]: print formatted documentation for
function using name.
Utilized by the \f[CR],doc\f[R] command, name is whatever symbol you
operate on that\[aq]s bound to the function.
.IP
.EX
local greet = fennel.eval(\[aq](λ greet [name] \[dq]Say hello\[dq] (print \[dq]Hello,\[dq] name))\[aq],
                          {useMetadata = true})

fennel.metadata[greet]
\-\- > {\[dq]fnl/docstring\[dq] = \[dq]Say hello\[dq], \[dq]fnl/arglist\[dq] = [\[dq]name\[dq]]}

fennel.doc(greet, \[dq]greet\[dq])
\-\- > (greet name)
\-\- >   Say hello

fennel.metadata:set(greet, \[dq]fnl/docstring\[dq], \[dq]Say hello!!!\[dq])
fennel.doc(greet, \[dq]greet!\[dq])
\-\-> (greet! name)
\-\->   Say hello!!!
.EE
.SS Metadata performance note
Enabling metadata in the compiler/eval/REPL will cause every function to
store a new table containing the function\[aq]s arglist and docstring in
the metadata table, weakly referenced by the function itself as a key.
.PP
This may have a performance impact in some applications due to the extra
allocations and garbage collection associated with dynamic function
creation.
The impact hasn\[aq]t been benchmarked, but enabling metadata is
currently recommended for development purposes only.
.SH DESCRIBE FENNEL SYNTAX
If you\[aq]re writing a tool which performs syntax highlighting or some
other operations on Fennel code, the \f[CR]fennel.syntax\f[R] function
can provide you with data about what forms and keywords to treat
specially.
.IP
.EX
local syntax = fennel.syntax()
print(fennel.view(syntax[\[dq]icollect\[dq]]))
\-\-> {:binding\-form? true :body\-form? true :macro? true}
.EE
.PP
The table has string keys and table values.
Each entry will have one of \f[CR]\[dq]macro?\[dq]\f[R],
\f[CR]\[dq]global?\[dq]\f[R], or \f[CR]\[dq]special?\[dq]\f[R] set to
\f[CR]true\f[R] indicating what type it is.
Globals can also have \f[CR]\[dq]function?\[dq]\f[R] set to true.
Macros and specials can have \f[CR]\[dq]binding\-form?\[dq]\f[R] set to
true indicating it accepts a \f[CR][]\f[R] argument which introduces new
locals, and/or a \f[CR]\[dq]body\-form?\[dq]\f[R] indicating whether it
should be indented with two spaces instead of being indented like a
function call.
They can also have a \f[CR]\[dq]define?\[dq]\f[R] key indicating whether
it introduces a new top\-level identifier like \f[CR]local\f[R] or
\f[CR]fn\f[R].
.SH LOAD LUA CODE IN A PORTABLE WAY
This isn\[aq]t Fennel\-specific, but the \f[CR]loadCode\f[R] function
takes a string of Lua code along with an optional environment table and
filename string, and returns a function for the loaded code which will
run inside that environment, in a way that\[aq]s portable across any Lua
5.1+ version.
.IP
.EX
local f = fennel.loadCode(luaCode, { x = y }, \[dq]myfile.lua\[dq])
.EE
.SH DETECT LUA VM RUNTIME VERSION
This function does a best effort detection of the Lua VM environment
hosting Fennel.
Useful for displaying an \[dq]About\[dq] dialog in your Fennel app that
matches the REPL and \f[CR]\-\-version\f[R] CLI flag.
.IP
.EX
(fennel.runtime\-version)
.EE
.IP
.EX
print(fennel.runtimeVersion())
\-\- > Fennel 1.0.0 on PUC Lua 5.4
.EE
.PP
The \f[CR]fennel.version\f[R] field will give you the version of just
Fennel itself.
.PP
\f[I](since 1.3.1)\f[R]
.PP
If an optional argument is given, returns version information as a
table:
.IP
.EX
(fennel.runtime\-version :as\-table)
;; > {:fennel \[dq]1.3.1\[dq] :lua \[dq]PUC Lua 5.4\[dq]}
.EE
.SH PLUGINS
Fennel\[aq]s plugin system is extremely experimental and exposes
internals of the compiler in ways that no other part of the compiler
does.
It should be considered unstable; changes to the compiler in future
versions are likely to break plugins, and each plugin should only be
assumed to work with specific versions of the compiler that they\[aq]re
tested against.
The backwards\-compatibility guarantees of the rest of Fennel \f[B]do
not apply\f[R] to plugins.
.PP
Compiler plugins allow the functionality of the compiler to be extended
in various ways.
A plugin is a module containing various functions in fields named after
different compiler extension points.
When the compiler hits an extension point, it will call each
plugin\[aq]s function for that extension point, if provided, with
various arguments; usually the AST in question and the scope table.
Each plugin function should normally do side effects and return nil or
error out.
If a function returns non\-nil, it will cause the rest of the plugins
for a given event to be skipped.
.IP \[bu] 2
\f[CR]symbol\-to\-expression\f[R]
.IP \[bu] 2
\f[CR]call\f[R]
.IP \[bu] 2
\f[CR]do\f[R]
.IP \[bu] 2
\f[CR]fn\f[R]
.IP \[bu] 2
\f[CR]destructure\f[R]
.IP \[bu] 2
\f[CR]parse\-error\f[R]
.IP \[bu] 2
\f[CR]assert\-compile\f[R]
.PP
The \f[CR]destructure\f[R] extension point is different because instead
of just taking \f[CR]ast\f[R] and \f[CR]scope\f[R] it takes a
\f[CR]from\f[R] which is the AST for the value being destructured and a
\f[CR]to\f[R] AST which is the AST for the form being destructured to.
This is most commonly a symbol but can be a list or a table.
.PP
The \f[CR]parse\-error\f[R] and \f[CR]assert\-compile\f[R] hooks can be
used to override how fennel behaves down to the parser and compiler
levels.
Possible use\-cases include building atop \f[CR]fennel.view\f[R] to
serialize data with \c
.UR https://clojure.github.io/clojure/clojure.edn-api.html
EDN
.UE \c
\-style tagging, or manipulating external s\-expression\-based syntax,
such as \c
.UR https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax
tree\-sitter queries
.UE \c
\&.
.PP
The \f[CR]scope\f[R] argument is a table containing all the
compiler\[aq]s information about the current scope.
Most of the tables here look up values in their parent scopes if they do
not contain a key.
.PP
Plugins can also contain repl commands.
If your plugin module has a field with a name beginning with
\[dq]repl\-command\-\[dq] then that function will be available as a
comma command from within a repl session.
It will be called with a table for the repl session\[aq]s environment, a
function which will read the next form from stdin (ignoring newlines and
other whitespace), a function which is used to print normal values, and
one which is used to print errors.
.IP
.EX
(local fennel (require :fennel)
(fn locals [env read on\-values on\-error scope chars opts]
  \[dq]Print all locals in repl session scope.\[dq]
  (on\-values [(fennel.view env.___replLocals___)]))

{:repl\-command\-locals locals}
.EE
.IP
.EX
$ fennel \-\-plugin locals\-plugin.fnl
Welcome to Fennel 0.8.0 on Lua 5.4!
Use ,help to see available commands.
>> (local x 4)
nil
>> (local abc :xyz)
nil
>> ,locals
{
  :abc \[dq]xyz\[dq]
  :x 4
}
.EE
.PP
The docstring of the function will be used as its summary in the
\[dq],help\[dq] command listing.
Unlike other plugin hook fields, only the first plugin to provide a repl
command will be used.
.SS Activation
Plugins are activated by passing the \f[CR]\-\-plugin\f[R] argument on
the command line, which should be a path to a Fennel file containing a
module that has some of the functions listed above.
If you\[aq]re using the compiler programmatically, you can include a
\f[CR]:plugins\f[R] table in the \f[CR]options\f[R] table to most
compiler entry point functions.
.PP
Your plugin should contain a \f[CR]:versions\f[R] field which either
contains a list of strings indicating every version of Fennel which you
have tested it with, or a string containing a pattern which is checked
against Fennel\[aq]s version with \f[CR]string.find\f[R].
If your plugin is used with a version of Fennel that doesn\[aq]t match
\f[CR]:versions\f[R] it will emit a warning.
You should also have a \f[CR]:name\f[R] field with the plugin\[aq]s
name.
.SH AUTHORS
Fennel Maintainers.
