.\" Automatically generated by Pandoc 3.1.11.1
.\"
.TH "fennel\-tutorial" "7" "2025\-12\-30" "fennel 1.6.1" "Getting Started with Fennel"
.SH NAME
fennel\-tutorial \- Getting Started with Fennel
.SH DESCRIPTION
A programming language is made up of \f[B]syntax\f[R] and
\f[B]semantics\f[R].
The semantics of Fennel vary only in small ways from Lua (all noted
below).
The syntax of Fennel comes from the lisp family of languages.
Lisps have syntax which is very uniform and predictable, which makes it
easier to \c
.UR https://stopa.io/post/265
write code that operates on code
.UE \c
\ as well as \c
.UR http://danmidwood.com/content/2014/11/21/animated-paredit.html
structured editing
.UE \c
\&.
.PP
If you know Lua and a lisp already, you\[aq]ll feel right at home in
Fennel.
Even if not, Lua is one of the simplest programming languages in
existence, so if you\[aq]ve programmed before you should be able to pick
it up without too much trouble, especially if you\[aq]ve used another
dynamically\-typed imperative language with closures.
The \c
.UR https://www.lua.org/manual/5.4/
Lua reference manual
.UE \c
\ is a fine place to look for details, but Fennel\[aq]s own \c
.UR https://fennel-lang.org/lua-primer
Lua Primer
.UE \c
\ is shorter and covers the highlights.
.PP
If you\[aq]ve already got some Lua example code and you just want to see
how it would look in Fennel, you can learn a lot from putting it in \c
.UR https://fennel-lang.org/see
antifennel
.UE \c
\&.
.SH OK, SO HOW DO YOU DO THINGS?
.SS Functions and lambdas
Use \f[CR]fn\f[R] to make functions.
If you provide an optional name, the function will be bound to that name
in local scope; otherwise it is simply an anonymous value.
.RS
.PP
A brief note on naming: identifiers are typically lowercase separated by
dashes (aka \[dq]kebab\-case\[dq]).
They may contain digits too, as long as they\[aq]re not at the start.
You can also use the question mark (typically for functions that return
a true or false, ex., \f[CR]at\-max\-velocity?\f[R]).
Underscores (\f[CR]_\f[R]) are often used to name a variable that we
don\[aq]t plan on using.
.RE
.PP
The argument list is provided in square brackets.
The final value in the body is returned.
.PP
(If you\[aq]ve never used a lisp before, the main thing to note is that
the function or macro being called goes \f[I]inside\f[R] the parens, not
outside.)
.IP
.EX
(fn print\-and\-add [a b c]
  (print a)
  (+ b c))
.EE
.PP
Functions can take an optional docstring in the form of a string that
immediately follows the argument list.
Under normal compilation, this is removed from the emitted Lua, but
during development in the REPL the docstring and function usage can be
viewed with the \f[CR],doc\f[R] command:
.IP
.EX
(fn print\-sep [sep ...]
  \[dq]Prints args as a string, delimited by sep\[dq]
  (print (table.concat [...] sep)))
,doc print\-sep ; \-> outputs:
;; (print\-sep sep ...)
;;   Prints args as a string, delimited by sep
.EE
.PP
Like other lisps, Fennel uses semicolons for comments.
.PP
Functions defined with \f[CR]fn\f[R] are fast; they have no runtime
overhead compared to Lua.
However, they also have no arity checking.
(That is, calling a function with the wrong number of arguments does not
cause an error.)
For safer code you can use \f[CR]lambda\f[R] which ensures you will get
at least as many arguments as you define, unless you signify that one
may be omitted by beginning its name with a \f[CR]?\f[R]:
.IP
.EX
(lambda print\-calculation [x ?y z]
  (print (\- x (* (or ?y 1) z))))

(print\-calculation 5) ; \-> error: Missing argument z
.EE
.PP
Note that the second argument \f[CR]?y\f[R] is allowed to be
\f[CR]nil\f[R], but \f[CR]z\f[R] is not:
.IP
.EX
(print\-calculation 5 nil 3) ; \-> 2
.EE
.PP
Like \f[CR]fn\f[R], lambdas accept an optional docstring after the
argument list.
.SS Locals and variables
Locals are introduced using \f[CR]let\f[R] with the names and values
wrapped in a single set of square brackets:
.IP
.EX
(let [x (+ 89 5.2)
      f (fn [abc] (print (* 2 abc)))]
  (f x))
.EE
.PP
Here \f[CR]x\f[R] is bound to the result of adding 89 and 5.2, while
\f[CR]f\f[R] is bound to a function that prints twice its argument.
These bindings are only valid inside the body of the \f[CR]let\f[R]
call.
All values are dynamically typed.
.PP
You can also introduce locals with \f[CR]local\f[R], which is nice when
they\[aq]ll be used across the whole file, but in general \f[CR]let\f[R]
is preferred inside functions because it\[aq]s clearer at a glance where
the value can be used:
.IP
.EX
(local tau\-approx 6.28318)
.EE
.PP
Locals set this way cannot be given new values, but you \f[I]can\f[R]
introduce new locals that shadow the outer names:
.IP
.EX
(let [x 19]
  ;; (set x 88) <\- not allowed!
  (let [x 88]
    (print (+ x 2))) ; \-> 90
  (print x)) ; \-> 19
.EE
.PP
If you need to change the value of a local, you can use \f[CR]var\f[R]
which works like \f[CR]local\f[R] except it allows \f[CR]set\f[R] to
work on it.
There is no nested \f[CR]let\f[R]\-like equivalent of \f[CR]var\f[R].
.IP
.EX
(var x 19)
(set x (+ x 8))
(print x) ; \-> 27
.EE
.PP
Note that introducing a table with \f[CR]local\f[R] or \f[CR]let\f[R]
does not prevent its \f[I]fields\f[R] from being changed using
\f[CR]set\f[R].
.SS Numbers and strings
Of course, all our standard arithmetic operators like \f[CR]+\f[R],
\f[CR]\-\f[R], \f[CR]*\f[R], and \f[CR]/\f[R] work here in prefix form.
Note that numbers are double\-precision floats in all Lua versions prior
to 5.3, which introduced integers.
On 5.3 and up, integer division uses \f[CR]//\f[R] and bitwise
operations use \f[CR]lshift\f[R], \f[CR]rshift\f[R], \f[CR]bor\f[R],
\f[CR]band\f[R], \f[CR]bnot\f[R] and \f[CR]xor\f[R].
Bitwise operators and integer division will not work if the host Lua
environment is older than version 5.3.
.PP
You may also use underscores to separate sections of long numbers.
The underscores have no effect on the value.
.IP
.EX
(let [x (+ 1 99)
      y (\- x 12)
      z 100_000]
  (+ z (/ y 10)))
.EE
.PP
Strings are essentially immutable byte arrays.
UTF\-8 support is provided in the \f[CR]utf8\f[R] table in \c
.UR https://www.lua.org/manual/5.3/manual.html#6.5
Lua 5.3+
.UE \c
\ or from a \c
.UR https://github.com/Stepets/utf8.lua
3rd\-party library
.UE \c
\ in earlier versions.
Strings are concatenated with \f[CR]..\f[R]:
.IP
.EX
(.. \[dq]hello\[dq] \[dq] world\[dq])
.EE
.SS Tables
In Lua (and thus in Fennel), tables are the only data structure.
The main syntax for tables uses curly braces with key/value pairs in
them:
.IP
.EX
{\[dq]key\[dq] value
 \[dq]number\[dq] 531
 \[dq]f\[dq] (fn [x] (+ x 2))}
.EE
.PP
You can use \f[CR].\f[R] to get data out of tables:
.IP
.EX
(let [tbl (function\-which\-returns\-a\-table)
      key \[dq]a certain key\[dq]]
  (. tbl key))
.EE
.PP
And \f[CR]tset\f[R] to put them in:
.IP
.EX
(let [tbl {}
      key1 \[dq]a long string\[dq]
      key2 12]
  (tset tbl key1 \[dq]the first value\[dq])
  (tset tbl key2 \[dq]the second one\[dq])
  tbl) ; \-> {\[dq]a long string\[dq] \[dq]the first value\[dq] 12 \[dq]the second one\[dq]}
.EE
.SS Sequential Tables
Some tables are used to store data that\[aq]s used sequentially; the
keys in this case are just numbers starting with 1 and going up.
Fennel provides alternate syntax for these tables with square brackets:
.IP
.EX
[\[dq]abc\[dq] \[dq]def\[dq] \[dq]xyz\[dq]] ; equivalent to {1 \[dq]abc\[dq] 2 \[dq]def\[dq] 3 \[dq]xyz\[dq]}
.EE
.PP
Lua\[aq]s built\-in \f[CR]table.insert\f[R] function is meant to be used
with sequential tables; all elements after the inserted value are
shifted up by one index: If you don\[aq]t provide an index to
\f[CR]table.insert\f[R] it will append to the end of the table.
.PP
The \f[CR]table.remove\f[R] function works similarly; it takes a table
and an index (which defaults to the end of the table) and removes the
value at that index, returning it.
.IP
.EX
(local ltrs [\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]d\[dq]])

(table.remove ltrs)       ; Removes \[dq]d\[dq]
(table.remove ltrs 1)     ; Removes \[dq]a\[dq]
(table.insert ltrs \[dq]d\[dq])   ; Appends \[dq]d\[dq]
(table.insert ltrs 1 \[dq]a\[dq]) ; Prepends \[dq]a\[dq]

(. ltrs 2)                ; \-> \[dq]b\[dq]
;; ltrs is back to its original value [\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]d\[dq]]
.EE
.PP
The \f[CR]length\f[R] form returns the length of sequential tables and
strings:
.IP
.EX
(let [tbl [\[dq]abc\[dq] \[dq]def\[dq] \[dq]xyz\[dq]]]
  (+ (length tbl)
     (length (. tbl 1)))) ; \-> 6
.EE
.PP
Note that the length of a table with gaps in it is undefined; it can
return a number corresponding to any of the table\[aq]s
\[dq]boundary\[dq] positions between nil and non\-nil values.
.PP
Lua\[aq]s standard library is very small, and thus several functions you
might expect to be included, such \f[CR]map\f[R], \f[CR]reduce\f[R], and
\f[CR]filter\f[R] are absent.
In Fennel macros are used for this instead; see \f[CR]icollect\f[R],
\f[CR]collect\f[R], and \f[CR]accumulate\f[R].
.SS Iteration
Looping over table elements is done with \f[CR]each\f[R] and an iterator
like \f[CR]pairs\f[R] (used for general tables) or \f[CR]ipairs\f[R]
(for sequential tables):
.IP
.EX
(each [key value (pairs {\[dq]key1\[dq] 52 \[dq]key2\[dq] 99})]
  (print key value))

(each [index value (ipairs [\[dq]abc\[dq] \[dq]def\[dq] \[dq]xyz\[dq]])]
  (print index value))
.EE
.PP
Note that whether a table is sequential or not is not an inherent
property of the table but depends on which iterator is used with it.
You can call \f[CR]ipairs\f[R] on any table, and it will only iterate
over numeric keys starting with 1 until it hits a \f[CR]nil\f[R].
.PP
You can use any \c
.UR https://www.lua.org/pil/7.1.html
Lua iterator
.UE \c
\ with \f[CR]each\f[R], but these are the most common.
Here\[aq]s an example that walks through \c
.UR https://www.lua.org/manual/5.4/manual.html#pdf-string.gmatch
matches in a string
.UE \c
:
.IP
.EX
(var sum 0)
(each [digits (string.gmatch \[dq]244 127 163\[dq] \[dq]%d+\[dq])]
  (set sum (+ sum (tonumber digits))))
.EE
.PP
If you want to get a table back, try \f[CR]icollect\f[R] to get a
sequential table or \f[CR]collect\f[R] to get a key/value one.
A body which returns nil will cause that to be omitted from the
resulting table.
.IP
.EX
(icollect [_ s (ipairs [:greetings :my :darling])]
  (if (not= :my s)
      (s:upper)))
;; \-> [\[dq]GREETINGS\[dq] \[dq]DARLING\[dq]]

(collect [_ s (ipairs [:greetings :my :darling])]
  s (length s))
;; \-> {:darling 7 :greetings 9 :my 2}
.EE
.PP
A lower\-level iteration construct is \f[CR]for\f[R] which iterates
numerically from the provided start value to the inclusive finish value:
.IP
.EX
(for [i 1 10]
  (print i))
.EE
.PP
You can specify an optional step value; this loop will only print odd
numbers under ten:
.IP
.EX
(for [i 1 10 2]
  (print i))
.EE
.SS Looping
If you need to loop but don\[aq]t know how many times, you can use
\f[CR]while\f[R]:
.IP
.EX
(while (keep\-looping?)
  (do\-something))
.EE
.SS Conditionals
Finally we have conditionals.
The \f[CR]if\f[R] form in Fennel can be used the same way as in other
lisp languages, but it can also be used as \f[CR]cond\f[R] for multiple
conditions compiling into \f[CR]elseif\f[R] branches:
.IP
.EX
(let [x (math.random 64)]
  (if (= 0 (% x 2))
      \[dq]even\[dq]
      (= 0 (% x 9))
      \[dq]multiple of nine\[dq]
      \[dq]I dunno, something else\[dq]))
.EE
.PP
With an odd number of arguments, the final clause is interpreted as
\[dq]else\[dq].
.PP
Being a lisp, Fennel has no statements, so \f[CR]if\f[R] returns a value
as an expression.
Lua programmers will be glad to know there is no need to construct
precarious chains of \f[CR]and\f[R]/\f[CR]or\f[R] just to get a value!
.PP
The other conditional is \f[CR]when\f[R], which is used for an arbitrary
number of side\-effects and has no else clause:
.IP
.EX
(when (currently\-raining?)
  (wear \[dq]boots\[dq])
  (deploy\-umbrella))
.EE
.SH BACK TO TABLES JUST FOR A BIT
Strings that don\[aq]t have spaces or reserved characters in them can
use the \f[CR]:shorthand\f[R] syntax instead, which is often used for
table keys:
.IP
.EX
{:key value :number 531}
.EE
.PP
If a table has string keys like this, you can pull fields out of it
easily with a dot if the keys are known up front:
.IP
.EX
(let [tbl {:x 52 :y 91}]
  (+ tbl.x tbl.y)) ; \-> 143
.EE
.PP
You can also use this syntax with \f[CR]set\f[R]:
.IP
.EX
(let [tbl {}]
  (set tbl.one 1)
  (set tbl.two 2)
  tbl) ; \-> {:one 1 :two 2}
.EE
.PP
If a table key has the same name as the variable you\[aq]re binding it
to, you can omit the key name and use \f[CR]:\f[R] instead:
.IP
.EX
(let [one 1 two 2
      tbl {: one : two}]
  tbl) ; \-> {:one 1 :two 2}
.EE
.PP
Finally, \f[CR]let\f[R] can destructure a table into multiple locals.
.PP
There is positional destructuring:
.IP
.EX
(let [data [1 2 3]
      [fst snd thrd] data]
  (print fst snd thrd)) ; \-> 1       2       3
.EE
.PP
And destructuring of tables via key:
.IP
.EX
(let [pos {:x 23 :y 42}
      {:x x\-pos :y y\-pos} pos]
  (print x\-pos y\-pos)) ; \-> 23      42
.EE
.PP
As above, if a table key has the same name as the variable you\[aq]re
destructuring it to, you can omit the key name and use \f[CR]:\f[R]
instead:
.IP
.EX
(let [pos {:x 23 :y 42}
      {: x : y} pos]
  (print x y)) ; \-> 23      42
.EE
.PP
This can nest and mix and match:
.IP
.EX
(let [f (fn [] [\[dq]abc\[dq] \[dq]def\[dq] {:x \[dq]xyz\[dq] :y \[dq]abc\[dq]}])
      [a d {:x x : y}] (f)]
  (print a d)
  (print x y))
.EE
.PP
If the size of the table doesn\[aq]t match the number of binding locals,
missing values are filled with \f[CR]nil\f[R] and extra values are
discarded.
Note that unlike many languages, \f[CR]nil\f[R] in Lua actually
represents the absence of a value, and thus tables cannot contain
\f[CR]nil\f[R].
It is an error to try to use \f[CR]nil\f[R] as a key, and using
\f[CR]nil\f[R] as a value removes whatever entry was at that key before.
.SH ERROR HANDLING
Errors in Lua have two forms they can take.
Functions in Lua can return any number of values, and most functions
which can fail will indicate failure by using two return values:
\f[CR]nil\f[R] followed by a failure message string.
You can interact with this style of function in Fennel by placing the
function call into a table and pattern matching against the table:
.IP
.EX
(case [(io.open \[dq]file\[dq])]
  ;; when io.open succeeds, it will return a file, but if it fails
  ;; it will return nil and an err\-msg string describing why
  [f] (do (use\-file\-contents (f:read :*all))
          (f:close))
  [nil err\-msg] (report\-error \[dq]Could not open file:\[dq] err\-msg))
.EE
.PP
You can write your own function which returns multiple values by calling
\f[CR]values\f[R].
.IP
.EX
(fn use\-file [filename]
  (if (valid\-file\-name? filename)
      (open\-file filename)
      (values nil (.. \[dq]Invalid filename: \[dq] filename))))
.EE
.PP
\f[B]Note\f[R]: while errors are the most common reason to return
multiple values from a function, it can be used in other cases as well.
This is the most complicated feature of Lua, and a full discussion is
out of scope for this tutorial, but it\[aq]s \c
.UR
https://benaiah.me/posts/everything-you-didnt-want-to-know-about-lua-multivals/
covered well elsewhere
.UE \c
\&.
.PP
The problem with this type of error is that it does not compose well;
the error status must be propagated all the way along the call chain
from inner to outer.
To address this, you can use \f[CR]error\f[R].
This will terminate the whole process unless it\[aq]s within a protected
call, similar to the way in other languages where throwing an exception
will stop the program unless it is within a try/catch.
You can make a protected call with \f[CR]pcall\f[R]:
.IP
.EX
(let [(ok? val\-or\-msg) (pcall potentially\-disastrous\-call filename)]
  (if ok?
      (print \[dq]Got value\[dq] val\-or\-msg)
      (print \[dq]Could not get value:\[dq] val\-or\-msg)))
.EE
.PP
The \f[CR]pcall\f[R] invocation there means you are running
\f[CR](potentially\-disastrous\-call filename)\f[R] in protected mode.
\f[CR]pcall\f[R] takes an arbitrary number of arguments which are passed
on to the function.
You can see that \f[CR]pcall\f[R] returns a boolean (\f[CR]ok?\f[R]
here) to let you know if the call succeeded or not, and a second value
(\f[CR]val\-or\-msg\f[R]) which is the actual value if it succeeded or
an error message if it didn\[aq]t.
.PP
The \f[CR]assert\f[R] function takes a value and an error message; it
calls \f[CR]error\f[R] if the value is \f[CR]nil\f[R] and returns it
otherwise.
This can be used to turn multiple\-value failures into errors (kind of
the inverse of \f[CR]pcall\f[R] which turns \f[CR]error\f[R]s into
multiple\-value failures):
.IP
.EX
(let [f (assert (io.open filename))
      contents (f.read f \[dq]*all\[dq])]
  (f.close f)
  contents)
.EE
.PP
In this example because \f[CR]io.open\f[R] returns \f[CR]nil\f[R] and an
error message upon failure, a failure will trigger an \f[CR]error\f[R]
and halt execution.
.SH VARIADIC FUNCTIONS
Fennel supports variadic functions (in other words, functions which take
any number of arguments) like many languages.
The syntax for taking a variable number of arguments to a function is
the \f[CR]...\f[R] symbol, which must be the last parameter to a
function.
This syntax is inherited from Lua rather than Lisp.
.PP
The \f[CR]...\f[R] form is not a list or first class value, it expands
to multiple values inline.
To access individual elements of the vararg, you can destructure with
parentheses, or first wrap it in a table literal (\f[CR][...]\f[R]) and
index like a normal table, or use the \f[CR]select\f[R] function from
Lua\[aq]s core library.
Often, the vararg can be passed directly to another function such as
\f[CR]print\f[R] without needing to bind it.
.IP
.EX
(fn print\-each [...]
  (each [i v (ipairs [...])]
    (print (.. \[dq]Argument \[dq] i \[dq] is \[dq] v))))

(print\-each :a :b :c)
.EE
.IP
.EX
(fn myprint [prefix ...]
  (io.write prefix)
  (io.write (.. (select \[dq]#\[dq] ...) \[dq] arguments given: \[dq]))
  (print ...))

(myprint \[dq]:D \[dq] :d :e :f)
.EE
.PP
Varargs are scoped differently than other variables as well \- they are
only accessible to the function in which they are created.
Unlike normal values, functions cannot close over them.
This means that the following code will NOT work, as the varargs in the
inner function are out of scope.
.IP
.EX
(fn badcode [...]
  (fn []
    (print ...)))
.EE
.SH STRICT GLOBAL CHECKING
If you get an error that says \f[CR]unknown global in strict mode\f[R]
it means that you\[aq]re trying compile code that uses a global which
the Fennel compiler doesn\[aq]t know about.
Most of the time, this is due to a coding mistake.
However, in some cases you may get this error with a legitimate global
reference.
If this happens, it may be due to an inherent limitation of Fennel\[aq]s
strategy.
You can use \f[CR]_G.myglobal\f[R] to refer to it in a way that works
around this check and calls attention to the fact that this is in fact a
global.
.PP
Another possible cause for this error is a modified \c
.UR https://www.lua.org/pil/14.3.html
function environment
.UE \c
\&.
The solution depends on how you\[aq]re using Fennel:
.IP \[bu] 2
Embedded Fennel can have its searcher modified to ignore certain (or
all) globals via the \f[CR]allowedGlobals\f[R] parameter.
See the \c
.UR https://fennel-lang.org/api
Lua API
.UE \c
\ page for instructions.
.IP \[bu] 2
Fennel\[aq]s CLI has the \f[CR]\-\-globals\f[R] parameter, which accepts
a comma\-separated list of globals to ignore.
For example, to disable strict mode for globals x, y, and z:
.RS 2
.IP
.EX
fennel \-\-globals x,y,z yourfennelscript.fnl
.EE
.RE
.SH GOTCHAS
There are a few surprises that might bite seasoned lispers.
Most of these result necessarily from Fennel\[aq]s insistence upon
imposing zero runtime overhead over Lua.
.IP \[bu] 2
The arithmetic, comparison, and boolean operators are not first\-class
functions.
They can behave in surprising ways with multiple\-return\-valued
functions, because the number of arguments to them must be known at
compile\-time.
.IP \[bu] 2
There is no \f[CR]apply\f[R] function; instead use
\f[CR]table.unpack\f[R] or \f[CR]unpack\f[R] depending on your Lua
version: \f[CR](f 1 3 (table.unpack [4 9]))\f[R] does what
\f[CR](apply f 1 3 [4 9])\f[R] would do in other lisps.
.IP \[bu] 2
Tables are compared for equality by identity, not based on the value of
their contents, as per \c
.UR https://p.hagelb.org/equal-rights-for-functional-objects.html
Baker
.UE \c
\&.
.IP \[bu] 2
Return values in the repl will get pretty\-printed, but calling
\f[CR](print tbl)\f[R] will emit output like
\f[CR]table: 0x55a3a8749ef0\f[R].
If you don\[aq]t already have one, it\[aq]s recommended for debugging to
define a printer function which calls \f[CR]fennel.view\f[R] on its
argument before printing it:
\f[CR](local fennel (require :fennel)) (fn _G.pp [x] (print (fennel.view x)))\f[R].
If you add this definition to your \f[CR]\[ti]/.fennelrc\f[R] file it
will be available in the standard repl.
.IP \[bu] 2
Lua programmers should note Fennel functions cannot do early returns.
.SH OTHER STUFF JUST WORKS
Note that built\-in functions in \c
.UR https://www.lua.org/manual/5.4/manual.html#6
Lua\[aq]s standard library
.UE \c
\ like \f[CR]math.random\f[R] above can be called with no fuss and no
overhead.
.PP
This includes features like coroutines, which are often implemented
using special syntax in other languages.
Coroutines \c
.UR https://leafo.net/posts/itchio-and-coroutines.html
let you express non\-blocking operations without callbacks
.UE \c
\&.
.PP
Tables in Lua may seem a bit limited, but \c
.UR https://www.lua.org/pil/13.html
metatables
.UE \c
\ allow a great deal more flexibility.
All the features of metatables are accessible from Fennel code just the
same as they would be from Lua.
.SH MODULES AND MULTIPLE FILES
You can use the \f[CR]require\f[R] function to load code from other
files.
.IP
.EX
(let [lume (require :lume)
      tbl [52 99 412 654]
      plus (fn [x y] (+ x y))]
  (lume.map tbl (partial plus 2))) ; \-> [54 101 414 656]
.EE
.PP
Modules in Fennel and Lua are simply tables which contain functions and
other values.
The last value in a Fennel file will be used as the value of the whole
module.
Technically this can be any value, not just a table, but using a table
is most common for good reason.
.PP
To require a module that\[aq]s in a subdirectory, take the file name,
replace the slashes with dots, and remove the extension, then pass that
to \f[CR]require\f[R].
For instance, a file called \f[CR]lib/ui/menu.lua\f[R] would be read
when loading the module \f[CR]lib.ui.menu\f[R].
.PP
When you run your program with the \f[CR]fennel\f[R] command, you can
call \f[CR]require\f[R] to load Fennel or Lua modules.
But in other contexts (such as compiling to Lua and then using the
\f[CR]lua\f[R] command, or in programs that embed Lua) it will not know
about Fennel modules.
You need to install the searcher that knows how to find \f[CR].fnl\f[R]
files:
.IP
.EX
require(\[dq]fennel\[dq]).install()
local mylib = require(\[dq]mylib\[dq]) \-\- will compile and load code in mylib.fnl
.EE
.PP
Once you add this, \f[CR]require\f[R] will work on Fennel files just
like it does with Lua; for instance \f[CR](require :mylib.parser)\f[R]
will look in \[dq]mylib/parser.fnl\[dq] on Fennel\[aq]s search path
(stored in \f[CR]fennel.path\f[R] which is distinct from
\f[CR]package.path\f[R] used to find Lua modules).
The path usually includes an entry to let you load things relative to
the current directory by default.
.SH RELATIVE REQUIRE
There are several ways to write a library which uses modules.
One of these is to rely on something like LuaRocks, to manage library
installation and availability of it and its modules.
Another way is to use the relative require style for loading nested
modules.
With relative require, libraries don\[aq]t depend on the root directory
name or its location when resolving inner module paths.
.PP
For example, here\[aq]s a small \f[CR]example\f[R] library, which
contains an \f[CR]init.fnl\f[R] file, and a module at the root
directory:
.IP
.EX
;; file example/init.fnl:
(local a (require :example.module\-a))

{:hello\-a a.hello}
.EE
.PP
Here, the main module requires additional \f[CR]example.module\-a\f[R]
module, which holds the implementation:
.IP
.EX
;; file example/module\-a.fnl
(fn hello [] (print \[dq]hello from a\[dq]))
{:hello hello}
.EE
.PP
The main issue here is that the path to the library must be exactly
\f[CR]example\f[R], e.g.
library must be required as \f[CR](require :example)\f[R] for it to
work, which can\[aq]t be enforced on the library user.
For example, if the library were moved into \f[CR]libs\f[R] directory of
the project to avoid cluttering, and required as
\f[CR](require :libs.example)\f[R], there will be a runtime error.
This happens because library itself will try to require
\f[CR]:example.module\-a\f[R] and not
\f[CR]:libs.example.module\-a\f[R], which is now the correct module
path:
.IP
.EX
runtime error: module \[aq]example.module\-a\[aq] not found:
        no field package.preload[\[aq]example.module\-a\[aq]]
        ...
        no file \[aq]./example/module\-a.lua\[aq]
        ...
stack traceback:
  [C]: in function \[aq]require\[aq]
  ./libs/example/init.fnl:2: in main chunk
.EE
.PP
LuaRocks addresses this problem by enforcing both the directory name and
installation path, populating the \f[CR]LUA_PATH\f[R] environment
variable to make the library available.
This, of course, can be done manually by setting \f[CR]LUA_PATH\f[R] per
project in the build pipeline, pointing it to the right directory.
But this is not very transparent, and when requiring a project local
library it\[aq]s better to see the full path, that directly maps to the
project\[aq]s file structure, rather than looking up where the
\f[CR]LUA_PATH\f[R] is modified.
.PP
In the Fennel ecosystem we encourage a simpler way of managing project
dependencies.
Simply dropping a library into your project\[aq]s tree or using git
submodule is usually enough, and the require paths should be handled by
the library itself.
.PP
Here\[aq]s how a relative require path can be specified in the
\f[CR]libs/example/init.fnl\f[R] to make it name/path agnostic, assuming
that we\[aq]ve moved our \f[CR]example\f[R] library there:
.IP
.EX
;; file libs/example/init.fnl:
(local a (require (.. ... :.module\-a)))

{:hello\-a a.hello}
.EE
.PP
Now, it doesn\[aq]t matter how library is named or where we put it \- we
can require it from anywhere.
It works because when requiring the library with
\f[CR](require :lib.example)\f[R], the first value in \f[CR]...\f[R]
will hold the \f[CR]\[dq]lib.example\[dq]\f[R] string.
This string is then concatenated with the
\f[CR]\[dq].module\-a\[dq]\f[R], and \f[CR]require\f[R] will properly
find and load the nested module at runtime under the
\f[CR]\[dq]lib.example.module\-a\[dq]\f[R] path.
It\[aq]s a Lua feature, and not something Fennel specific, and it will
work the same when the library is AOT compiled to Lua.
.SS Compile\-time relative include
Since Fennel v0.10.0 this also works at compile\-time, when using the
\f[CR]include\f[R] special or the \f[CR]\-\-require\-as\-include\f[R]
flag, with the constraint that the expression can be computed at compile
time.
This means that the expression must be self\-contained, i.e.
doesn\[aq]t refer to locals or globals, but embeds all values directly.
In other words, the following code will only work at runtime, but not
with \f[CR]include\f[R] or \f[CR]\-\-require\-as\-include\f[R] because
\f[CR]current\-module\f[R] is not known at compile time:
.IP
.EX
(local current\-module ...)
(require (.. current\-module :.other\-module))
.EE
.PP
This, on the other hand, will work both at runtime and at compile time:
.IP
.EX
(require (.. ... :.other\-module))
.EE
.PP
The \f[CR]...\f[R] module args are propagated during compilation, so
when the application which uses this library is compiled, all library
code is correctly included into the self\-contained Lua file.
.PP
Compiling a project that uses this \f[CR]example\f[R] library with
\f[CR]\-\-require\-as\-include\f[R] will include the following section
in the resulting Lua code:
.IP
.EX
package.preload[\[dq]libs.example.module\-a\[dq]] = package.preload[\[dq]libs.example.module\-a\[dq]] or function(...)
  local function hello()
    return print(\[dq]hello from a\[dq])
  end
  return {hello = hello}
end
.EE
.PP
Note that the \f[CR]package.preload\f[R] entry contains a fully
qualified path \f[CR]\[dq]libs.example.module\-a\[dq]\f[R], which was
resolved at compile time.
.SS Requiring modules from modules other than \f[CR]init.fnl\f[R]
To require a module from a module other than \f[CR]init\f[R] module, we
must keep the path up to the current module, but remove the module name.
For example, let\[aq]s add a \f[CR]greet\f[R] module in
\f[CR]libs/example/utils/greet.fnl\f[R], and require it from
\f[CR]libs/example/module\-a.fnl\f[R]:
.IP
.EX
;; file libs/example/utils/greet.fnl:
(fn greet [who] (print (.. \[dq]hello \[dq] who)))
.EE
.PP
This module can be required as follows:
.IP
.EX
;; file libs/example/module\-a.fnl
(local greet (require (.. (: ... :match \[dq](.+)%.[\[ha].]+\[dq]) :.utils.greet)))

(fn hello [] (print \[dq]hello from a\[dq]))

{:hello hello :greet greet}
.EE
.PP
The parent module name is determined via calling the \f[CR]match\f[R]
method on the current module name string (\f[CR]...\f[R]).
.SH AUTHORS
Fennel Maintainers.
