.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "fennel-tutorial" "7" "2023-07-05" "fennel 1.3.1-dev" "Getting Started with Fennel"
.hy
.SH NAME
.PP
fennel-tutorial - Getting Started with Fennel
.SH DESCRIPTION
.PP
A programming language is made up of \f[B]syntax\f[R] and
\f[B]semantics\f[R].
The semantics of Fennel vary only in small ways from Lua (all noted
below).
The syntax of Fennel comes from the lisp family of languages.
Lisps have syntax which is very uniform and predictable, which makes it
easier to write code that operates on code (https://stopa.io/post/265)
as well as structured
editing (http://danmidwood.com/content/2014/11/21/animated-paredit.html).
.PP
If you know Lua and a lisp already, you\[aq]ll feel right at home in
Fennel.
Even if not, Lua is one of the simplest programming languages in
existence, so if you\[aq]ve programmed before you should be able to pick
it up without too much trouble, especially if you\[aq]ve used another
dynamic imperative language with closures.
The Lua reference manual (https://www.lua.org/manual/5.1/) is a fine
place to look for details, but Fennel\[aq]s own Lua
Primer (https://fennel-lang.org/lua-primer) is shorter and covers the
highlights.
.PP
If you\[aq]ve already got some Lua example code and you just want to see
how it would look in Fennel, you can learn a lot from putting it in
antifennel (https://fennel-lang.org/see).
.SH OK, SO HOW DO YOU DO THINGS?
.SS Functions and lambdas
.PP
Use \f[V]fn\f[R] to make functions.
If you provide an optional name, the function will be bound to that name
in local scope; otherwise it is simply an anonymous value.
.RS
.PP
A brief note on naming: identifiers are typically lowercase separated by
dashes (aka \[dq]kebab-case\[dq]).
They may contain digits too, as long as they\[aq]re not at the start.
You can also use the question mark (typically for functions that return
a true or false, ex., \f[V]at-max-velocity?\f[R]).
Underscores (\f[V]_\f[R]) are often used to name a variable that we
don\[aq]t plan on using.
.RE
.PP
The argument list is provided in square brackets.
The final value in the body is returned.
.PP
(If you\[aq]ve never used a lisp before, the main thing to note is that
the function or macro being called goes \f[I]inside\f[R] the parens, not
outside.)
.IP
.nf
\f[C]
(fn print-and-add [a b c]
  (print a)
  (+ b c))
\f[R]
.fi
.PP
Functions can take an optional docstring in the form of a string that
immediately follows the arglist.
Under normal compilation, this is removed from the emitted Lua, but
during development in the REPL the docstring and function usage can be
viewed with the \f[V],doc\f[R] command:
.IP
.nf
\f[C]
(fn print-sep [sep ...]
  \[dq]Prints args as a string, delimited by sep\[dq]
  (print (table.concat [...] sep)))
,doc print-sep ; -> outputs:
;; (print-sep sep ...)
;;   Prints args as a string, delimited by sep
\f[R]
.fi
.PP
Like other lisps, Fennel uses semicolons for comments.
.PP
Functions defined with \f[V]fn\f[R] are fast; they have no runtime
overhead compared to Lua.
However, they also have no arity checking.
(That is, calling a function with the wrong number of arguments does not
cause an error.)
For safer code you can use \f[V]lambda\f[R] which ensures you will get
at least as many arguments as you define, unless you signify that one
may be omitted by beginning its name with a \f[V]?\f[R]:
.IP
.nf
\f[C]
(lambda print-calculation [x ?y z]
  (print (- x (* (or ?y 1) z))))

(print-calculation 5) ; -> error: Missing argument z
\f[R]
.fi
.PP
Note that the second argument \f[V]?y\f[R] is allowed to be
\f[V]nil\f[R], but \f[V]z\f[R] is not:
.IP
.nf
\f[C]
(print-calculation 5 nil 3) ; -> 2
\f[R]
.fi
.PP
Like \f[V]fn\f[R], lambdas accept an optional docstring after the
arglist.
.SS Locals and variables
.PP
Locals are introduced using \f[V]let\f[R] with the names and values
wrapped in a single set of square brackets:
.IP
.nf
\f[C]
(let [x (+ 89 5.2)
      f (fn [abc] (print (* 2 abc)))]
  (f x))
\f[R]
.fi
.PP
Here \f[V]x\f[R] is bound to the result of adding 89 and 5.2, while
\f[V]f\f[R] is bound to a function that prints twice its argument.
These bindings are only valid inside the body of the \f[V]let\f[R] call.
.PP
You can also introduce locals with \f[V]local\f[R], which is nice when
they\[aq]ll be used across the whole file, but in general \f[V]let\f[R]
is preferred because it\[aq]s clearer at a glance where the value is
used:
.IP
.nf
\f[C]
(local tau-approx 6.28318)
\f[R]
.fi
.PP
Locals set this way cannot be given new values, but you \f[I]can\f[R]
introduce new locals that shadow the outer names:
.IP
.nf
\f[C]
(let [x 19]
  ;; (set x 88) <- not allowed!
  (let [x 88]
    (print (+ x 2))) ; -> 90
  (print x)) ; -> 19
\f[R]
.fi
.PP
If you need to change the value of a local, you can use \f[V]var\f[R]
which works like \f[V]local\f[R] except it allows \f[V]set\f[R] to work
on it.
There is no nested \f[V]let\f[R]-like equivalent of \f[V]var\f[R].
.IP
.nf
\f[C]
(var x 19)
(set x (+ x 8))
(print x) ; -> 27
\f[R]
.fi
.SS Numbers and strings
.PP
Of course, all our standard arithmetic operators like \f[V]+\f[R],
\f[V]-\f[R], \f[V]*\f[R], and \f[V]/\f[R] work here in prefix form.
Note that numbers are double-precision floats in all Lua versions prior
to 5.3, which optionally introduced integers.
On 5.3 and up, integer division uses \f[V]//\f[R] and bitwise operations
use \f[V]lshift\f[R], \f[V]rshift\f[R], \f[V]bor\f[R], \f[V]band\f[R],
\f[V]bnot\f[R] and \f[V]xor\f[R].
Bitwise operators and integer division will not work if the host Lua
environment is older than version 5.3.
.PP
You may also use underscores to separate sections of long numbers.
The underscores have no effect on the output.
.IP
.nf
\f[C]
(let [x (+ 1 99)
      y (- x 12)
      z 100_000]
  (+ z (/ y 10)))
\f[R]
.fi
.PP
Strings are essentially immutable byte arrays.
UTF-8 support is provided in the \f[V]utf8\f[R] table in Lua
5.3+ (https://www.lua.org/manual/5.3/manual.html#6.5) or from a
3rd-party library (https://github.com/Stepets/utf8.lua) in earlier
versions.
Strings are concatenated with \f[V]..\f[R]:
.IP
.nf
\f[C]
(.. \[dq]hello\[dq] \[dq] world\[dq])
\f[R]
.fi
.SS Tables
.PP
In Lua (and thus in Fennel), tables are the only data structure.
The main syntax for tables uses curly braces with key/value pairs in
them:
.IP
.nf
\f[C]
{\[dq]key\[dq] value
 \[dq]number\[dq] 531
 \[dq]f\[dq] (fn [x] (+ x 2))}
\f[R]
.fi
.PP
You can use \f[V].\f[R] to get values out of tables:
.IP
.nf
\f[C]
(let [tbl (function-which-returns-a-table)
      key \[dq]a certain key\[dq]]
  (. tbl key))
\f[R]
.fi
.PP
And \f[V]tset\f[R] to put them in:
.IP
.nf
\f[C]
(let [tbl {}
      key1 \[dq]a long string\[dq]
      key2 12]
  (tset tbl key1 \[dq]the first value\[dq])
  (tset tbl key2 \[dq]the second one\[dq])
  tbl) ; -> {\[dq]a long string\[dq] \[dq]the first value\[dq] 12 \[dq]the second one\[dq]}
\f[R]
.fi
.SS Sequential Tables
.PP
Some tables are used to store data that\[aq]s used sequentially; the
keys in this case are just numbers starting with 1 and going up.
Fennel provides alternate syntax for these tables with square brackets:
.IP
.nf
\f[C]
[\[dq]abc\[dq] \[dq]def\[dq] \[dq]xyz\[dq]] ; equivalent to {1 \[dq]abc\[dq] 2 \[dq]def\[dq] 3 \[dq]xyz\[dq]}
\f[R]
.fi
.PP
Lua\[aq]s built-in \f[V]table.insert\f[R] function is meant to be used
with sequential tables; all values after the inserted value are shifted
up by one index: If you don\[aq]t provide an index to
\f[V]table.insert\f[R] it will append to the end of the table.
.PP
The \f[V]table.remove\f[R] function works similarly; it takes a table
and an index (which defaults to the end of the table) and removes the
value at that index, returning it.
.IP
.nf
\f[C]
(local ltrs [\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]d\[dq]])

(table.remove ltrs)       ; Removes \[dq]d\[dq]
(table.remove ltrs 1)     ; Removes \[dq]a\[dq]
(table.insert ltrs \[dq]d\[dq])   ; Appends \[dq]d\[dq]
(table.insert ltrs 1 \[dq]a\[dq]) ; Prepends \[dq]a\[dq]

(. ltrs 2)                ; -> \[dq]b\[dq]
;; ltrs is back to its original value [\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]d\[dq]]
\f[R]
.fi
.PP
The \f[V]length\f[R] form returns the length of sequential tables and
strings:
.IP
.nf
\f[C]
(let [tbl [\[dq]abc\[dq] \[dq]def\[dq] \[dq]xyz\[dq]]]
  (+ (length tbl)
     (length (. tbl 1)))) ; -> 6
\f[R]
.fi
.PP
Note that the length of a table with gaps in it is undefined; it can
return a number corresponding to any of the table\[aq]s
\[dq]boundary\[dq] positions between nil and non-nil values.
.PP
Lua\[aq]s standard library is very small, and thus several functions you
might expect to be included, such \f[V]map\f[R], \f[V]reduce\f[R], and
\f[V]filter\f[R] are absent.
In Fennel macros are used for this instead; see \f[V]icollect\f[R],
\f[V]collect\f[R], and \f[V]accumulate\f[R].
.SS Iteration
.PP
Looping over table elements is done with \f[V]each\f[R] and an iterator
like \f[V]pairs\f[R] (used for general tables) or \f[V]ipairs\f[R] (for
sequential tables):
.IP
.nf
\f[C]
(each [key value (pairs {\[dq]key1\[dq] 52 \[dq]key2\[dq] 99})]
  (print key value))

(each [index value (ipairs [\[dq]abc\[dq] \[dq]def\[dq] \[dq]xyz\[dq]])]
  (print index value))
\f[R]
.fi
.PP
Note that whether a table is sequential or not is not an inherent
property of the table but depends on which iterator is used with it.
You can call \f[V]ipairs\f[R] on any table, and it will only iterate
over numeric keys starting with 1 until it hits a \f[V]nil\f[R].
.PP
You can use any Lua iterator (https://www.lua.org/pil/7.1.html) with
\f[V]each\f[R], but these are the most common.
Here\[aq]s an example that walks through matches in a
string (https://www.lua.org/manual/5.1/manual.html#pdf-string.gmatch):
.IP
.nf
\f[C]
(var sum 0)
(each [digits (string.gmatch \[dq]244 127 163\[dq] \[dq]%d+\[dq])]
  (set sum (+ sum (tonumber digits))))
\f[R]
.fi
.PP
If you want to get a table back, try \f[V]icollect\f[R] to get a
sequential table or \f[V]collect\f[R] to get a key/value one.
A body which returns nil will cause that to be omitted from the
resulting table.
.IP
.nf
\f[C]
(icollect [_ s (ipairs [:greetings :my :darling])]
  (if (not= :my s)
      (s:upper)))
;; -> [\[dq]GREETINGS\[dq] \[dq]DARLING\[dq]]

(collect [_ s (ipairs [:greetings :my :darling])]
  s (length s))
;; -> {:darling 7 :greetings 9 :my 2}
\f[R]
.fi
.PP
A lower-level iteration construct is \f[V]for\f[R] which iterates
numerically from the provided start value to the inclusive finish value:
.IP
.nf
\f[C]
(for [i 1 10]
  (print i))
\f[R]
.fi
.PP
You can specify an optional step value; this loop will only print odd
numbers under ten:
.IP
.nf
\f[C]
(for [i 1 10 2]
  (print i))
\f[R]
.fi
.SS Looping
.PP
If you need to loop but don\[aq]t know how many times, you can use
\f[V]while\f[R]:
.IP
.nf
\f[C]
(while (keep-looping?)
  (do-something))
\f[R]
.fi
.SS Conditionals
.PP
Finally we have conditionals.
The \f[V]if\f[R] form in Fennel can be used the same way as in other
lisp languages, but it can also be used as \f[V]cond\f[R] for multiple
conditions compiling into \f[V]elseif\f[R] branches:
.IP
.nf
\f[C]
(let [x (math.random 64)]
  (if (= 0 (% x 2))
      \[dq]even\[dq]
      (= 0 (% x 9))
      \[dq]multiple of nine\[dq]
      \[dq]I dunno, something else\[dq]))
\f[R]
.fi
.PP
With an odd number of arguments, the final clause is interpreted as
\[dq]else\[dq].
.PP
Being a lisp, Fennel has no statements, so \f[V]if\f[R] returns a value
as an expression.
Lua programmers will be glad to know there is no need to construct
precarious chains of \f[V]and\f[R]/\f[V]or\f[R] just to get a value!
.PP
The other conditional is \f[V]when\f[R], which is used for an arbitrary
number of side-effects and has no else clause:
.IP
.nf
\f[C]
(when (currently-raining?)
  (wear \[dq]boots\[dq])
  (deploy-umbrella))
\f[R]
.fi
.SH BACK TO TABLES JUST FOR A BIT
.PP
Strings that don\[aq]t have spaces or reserved characters in them can
use the \f[V]:shorthand\f[R] syntax instead, which is often used for
table keys:
.IP
.nf
\f[C]
{:key value :number 531}
\f[R]
.fi
.PP
If a table has string keys like this, you can pull values out of it
easily with a dot if the keys are known up front:
.IP
.nf
\f[C]
(let [tbl {:x 52 :y 91}]
  (+ tbl.x tbl.y)) ; -> 143
\f[R]
.fi
.PP
You can also use this syntax with \f[V]set\f[R]:
.IP
.nf
\f[C]
(let [tbl {}]
  (set tbl.one 1)
  (set tbl.two 2)
  tbl) ; -> {:one 1 :two 2}
\f[R]
.fi
.PP
If a table key has the same name as the variable you\[aq]re setting it
to, you can omit the key name and use \f[V]:\f[R] instead:
.IP
.nf
\f[C]
(let [one 1 two 2
      tbl {: one : two}]
  tbl) ; -> {:one 1 :two 2}
\f[R]
.fi
.PP
Finally, \f[V]let\f[R] can destructure a table into multiple locals.
.PP
There is positional destructuring:
.IP
.nf
\f[C]
(let [data [1 2 3]
      [fst snd thrd] data]
  (print fst snd thrd)) ; -> 1       2       3
\f[R]
.fi
.PP
And destructuring of tables via key:
.IP
.nf
\f[C]
(let [pos {:x 23 :y 42}
      {:x x-pos :y y-pos} pos]
  (print x-pos y-pos)) ; -> 23      42
\f[R]
.fi
.PP
As above, if a table key has the same name as the variable you\[aq]re
destructuring it to, you can omit the key name and use \f[V]:\f[R]
instead:
.IP
.nf
\f[C]
(let [pos {:x 23 :y 42}
      {: x : y} pos]
  (print x y)) ; -> 23      42
\f[R]
.fi
.PP
This can nest and mix and match:
.IP
.nf
\f[C]
(let [f (fn [] [\[dq]abc\[dq] \[dq]def\[dq] {:x \[dq]xyz\[dq] :y \[dq]abc\[dq]}])
      [a d {:x x : y}] (f)]
  (print a d)
  (print x y))
\f[R]
.fi
.PP
If the size of the table doesn\[aq]t match the number of binding locals,
missing values are filled with \f[V]nil\f[R] and extra values are
discarded.
Note that unlike many languages, \f[V]nil\f[R] in Lua actually
represents the absence of a value, and thus tables cannot contain
\f[V]nil\f[R].
It is an error to try to use \f[V]nil\f[R] as a key, and using
\f[V]nil\f[R] as a value removes whatever entry was at that key before.
.SH ERROR HANDLING
.PP
Errors in Lua have two forms they can take.
Functions in Lua can return any number of values, and most functions
which can fail will indicate failure by using two return values:
\f[V]nil\f[R] followed by a failure message string.
You can interact with this style of function in Fennel by destructuring
with parens instead of square brackets:
.IP
.nf
\f[C]
(match (io.open \[dq]file\[dq])
  ;; when io.open succeeds, it will return a file, but if it fails it will
  ;; return nil and an err-msg string describing why
  f (do (use-file-contents (f:read :*all))
        (f:close))
  (nil err-msg) (print \[dq]Could not open file:\[dq] err-msg))
\f[R]
.fi
.PP
You can write your own function which returns multiple values with
\f[V]values\f[R].
.IP
.nf
\f[C]
(fn use-file [filename]
  (if (valid-file-name? filename)
      (open-file filename)
      (values nil (.. \[dq]Invalid filename: \[dq] filename))))
\f[R]
.fi
.PP
\f[B]Note\f[R]: while errors are the most common reason to return
multiple values from a function, it can be used in other cases as well.
This is the most complex thing about Lua, and a full discussion is out
of scope for this tutorial, but it\[aq]s covered well
elsewhere (https://benaiah.me/posts/everything-you-didnt-want-to-know-about-lua-multivals/).
.PP
The problem with this type of error is that it does not compose well;
the error status must be propagated all the way along the call chain
from inner to outer.
To address this, you can use \f[V]error\f[R].
This will terminate the whole process unless it\[aq]s within a protected
call, similar to the way in other languages where throwing an exception
will stop the program unless it is within a try/catch.
You can make a protected call with \f[V]pcall\f[R]:
.IP
.nf
\f[C]
(let [(ok? val-or-msg) (pcall potentially-disastrous-call filename)]
  (if ok?
      (print \[dq]Got value\[dq] val-or-msg)
      (print \[dq]Could not get value:\[dq] val-or-msg)))
\f[R]
.fi
.PP
The \f[V]pcall\f[R] invocation there means you are running
\f[V](potentially-disastrous-call filename)\f[R] in protected mode.
\f[V]pcall\f[R] takes an arbitrary number of arguments which are passed
on to the function.
You can see that \f[V]pcall\f[R] returns a boolean (\f[V]ok?\f[R] here)
to let you know if the call succeeded or not, and a second value
(\f[V]val-or-msg\f[R]) which is the actual value if it succeeded or an
error message if it didn\[aq]t.
.PP
The \f[V]assert\f[R] function takes a value and an error message; it
calls \f[V]error\f[R] if the value is \f[V]nil\f[R] and returns it
otherwise.
This can be used to turn multiple-value failures into errors (kind of
the inverse of \f[V]pcall\f[R] which turns \f[V]error\f[R]s into
multiple-value failures):
.IP
.nf
\f[C]
(let [f (assert (io.open filename))
      contents (f.read f \[dq]*all\[dq])]
  (f.close f)
  contents)
\f[R]
.fi
.PP
In this example because \f[V]io.open\f[R] returns \f[V]nil\f[R] and an
error message upon failure, a failure will trigger an \f[V]error\f[R]
and halt execution.
.SH VARIADIC FUNCTIONS
.PP
Fennel supports variadic functions like many languages.
The syntax for taking a variable number of arguments to a function is
the \f[V]...\f[R] symbol, which must be the last parameter to a
function.
This syntax is inherited from Lua rather than Lisp.
.PP
The \f[V]...\f[R] form is not a list or first class value, it expands to
multiple values inline.
To access individual elements of the vararg, you can destructure with
parentheses, or first wrap it in a table literal (\f[V][...]\f[R]) and
index like a normal table, or use the \f[V]select\f[R] function from
Lua\[aq]s core library.
Often, the vararg can be passed directly to another function such as
\f[V]print\f[R] without needing to bind it.
.IP
.nf
\f[C]
(fn print-each [...]
  (each [i v (ipairs [...])]
    (print (.. \[dq]Argument \[dq] i \[dq] is \[dq] v))))

(print-each :a :b :c)
\f[R]
.fi
.IP
.nf
\f[C]
(fn myprint [prefix ...]
  (io.write prefix)
  (io.write (.. (select \[dq]#\[dq] ...) \[dq] arguments given: \[dq]))
  (print ...))

(myprint \[dq]:D \[dq] :d :e :f)
\f[R]
.fi
.PP
Varargs are scoped differently than other variables as well - they are
only accessible to the function in which they are created.
This means that the following code will NOT work, as the varargs in the
inner function are out of scope.
.IP
.nf
\f[C]
(fn badcode [...]
  (fn []
    (print ...)))
\f[R]
.fi
.PP
You can read more detailed coverage of some of the problems with
\f[V]...\f[R] and multiple
values (https://benaiah.me/posts/everything-you-didnt-want-to-know-about-lua-multivals/)
here.
.SH STRICT GLOBAL CHECKING
.PP
If you get an error that says \f[V]unknown global in strict mode\f[R] it
means that you\[aq]re trying compile code that uses a global which the
Fennel compiler doesn\[aq]t know about.
Most of the time, this is due to a coding mistake.
However, in some cases you may get this error with a legitimate global
reference.
If this happens, it may be due to an inherent limitation of Fennel\[aq]s
strategy.
You can use \f[V]_G.myglobal\f[R] to refer to it in a way that works
around this check and calls attention to the fact that this is in fact a
global.
.PP
Another possible cause for this error is a modified function
environment (https://www.lua.org/pil/14.3.html).
The solution depends on how you\[aq]re using Fennel:
.IP \[bu] 2
Embedded Fennel can have its searcher modified to ignore certain (or
all) globals via the \f[V]allowedGlobals\f[R] parameter.
See the Lua API (https://fennel-lang.org/api) page for instructions.
.IP \[bu] 2
Fennel\[aq]s CLI has the \f[V]--globals\f[R] parameter, which accepts a
comma-separated list of globals to ignore.
For example, to disable strict mode for globals x, y, and z:
.RS 2
.IP
.nf
\f[C]
fennel --globals x,y,z yourfennelscript.fnl
\f[R]
.fi
.RE
.SH GOTCHAS
.PP
There are a few surprises that might bite seasoned lispers.
Most of these result necessarily from Fennel\[aq]s insistence upon
imposing zero runtime overhead over Lua.
.IP \[bu] 2
The arithmetic, comparison, and boolean operators are not first-class
functions.
They can behave in surprising ways with multiple-return-valued
functions, because the number of arguments to them must be known at
compile-time.
.IP \[bu] 2
There is no \f[V]apply\f[R] function; instead use \f[V]table.unpack\f[R]
or \f[V]unpack\f[R] depending on your Lua version:
\f[V](f 1 3 (table.unpack [4 9]))\f[R].
.IP \[bu] 2
Tables are compared for identity, not based on the value of their
contents, as per
Baker (https://p.hagelb.org/equal-rights-for-functional-objects.html).
.IP \[bu] 2
Return values in the repl will get pretty-printed, but calling
\f[V](print tbl)\f[R] will emit output like
\f[V]table: 0x55a3a8749ef0\f[R].
If you don\[aq]t already have one, it\[aq]s recommended for debugging to
define a printer function which calls \f[V]fennel.view\f[R] on its
argument before printing it:
\f[V](local fennel (require :fennel)) (fn _G.pp [x] (print (fennel.view x)))\f[R]
.IP \[bu] 2
Lua programmers should note Fennel functions cannot do early returns.
.SH OTHER STUFF JUST WORKS
.PP
Note that built-in functions in Lua\[aq]s standard
library (https://www.lua.org/manual/5.1/manual.html#5) like
\f[V]math.random\f[R] above can be called with no fuss and no overhead.
.PP
This includes features like coroutines, which are often implemented
using special syntax in other languages.
Coroutines let you express non-blocking operations without
callbacks (https://leafo.net/posts/itchio-and-coroutines.html).
.PP
Tables in Lua may seem a bit limited, but
metatables (https://www.lua.org/pil/13.html) allow a great deal more
flexibility.
All the features of metatables are accessible from Fennel code just the
same as they would be from Lua.
.SH MODULES AND MULTIPLE FILES
.PP
You can use the \f[V]require\f[R] function to load code from other
files.
.IP
.nf
\f[C]
(let [lume (require :lume)
      tbl [52 99 412 654]
      plus (fn [x y] (+ x y))]
  (lume.map tbl (partial plus 2))) ; -> [54 101 414 656]
\f[R]
.fi
.PP
Modules in Fennel and Lua are simply tables which contain functions and
other values.
The last value in a Fennel file will be used as the value of the whole
module.
Technically this can be any value, not just a table, but using a table
is most common for good reason.
.PP
To require a module that\[aq]s in a subdirectory, take the file name,
replace the slashes with dots, and remove the extension, then pass that
to \f[V]require\f[R].
For instance, a file called \f[V]lib/ui/menu.lua\f[R] would be read when
loading the module \f[V]lib.ui.menu\f[R].
.PP
When you run your program with the \f[V]fennel\f[R] command, you can
call \f[V]require\f[R] to load Fennel or Lua modules.
But in other contexts (such as compiling to Lua and then using the
\f[V]lua\f[R] command, or in programs that embed Lua) it will not know
about Fennel modules.
You need to install the searcher that knows how to find \f[V].fnl\f[R]
files:
.IP
.nf
\f[C]
require(\[dq]fennel\[dq]).install()
local mylib = require(\[dq]mylib\[dq]) -- will compile and load code in mylib.fnl
\f[R]
.fi
.PP
Once you add this, \f[V]require\f[R] will work on Fennel files just like
it does with Lua; for instance \f[V](require :mylib.parser)\f[R] will
look in \[dq]mylib/parser.fnl\[dq] on Fennel\[aq]s search path (stored
in \f[V]fennel.path\f[R] which is distinct from \f[V]package.path\f[R]
used to find Lua modules).
The path usually includes an entry to let you load things relative to
the current directory by default.
.SH RELATIVE REQUIRE
.PP
There are several ways to write a library which uses modules.
One of these is to rely on something like LuaRocks, to manage library
installation and availability of it and its modules.
Another way is to use the relative require style for loading nested
modules.
With relative require, libraries don\[aq]t depend on the root directory
name or its location when resolving inner module paths.
.PP
For example, here\[aq]s a small \f[V]example\f[R] library, which
contains an \f[V]init.fnl\f[R] file, and a module at the root directory:
.IP
.nf
\f[C]
;; file example/init.fnl:
(local a (require :example.module-a))

{:hello-a a.hello}
\f[R]
.fi
.PP
Here, the main module requires additional \f[V]example.module-a\f[R]
module, which holds the implementation:
.IP
.nf
\f[C]
;; file example/module-a.fnl
(fn hello [] (print \[dq]hello from a\[dq]))
{:hello hello}
\f[R]
.fi
.PP
The main issue here is that the path to the library must be exactly
\f[V]example\f[R], e.g.
library must be required as \f[V](require :example)\f[R] for it to work,
which can\[aq]t be enforced on the library user.
For example, if the library were moved into \f[V]libs\f[R] directory of
the project to avoid cluttering, and required as
\f[V](require :libs.example)\f[R], there will be a runtime error.
This happens because library itself will try to require
\f[V]:example.module-a\f[R] and not \f[V]:libs.example.module-a\f[R],
which is now the correct module path:
.IP
.nf
\f[C]
runtime error: module \[aq]example.module-a\[aq] not found:
        no field package.preload[\[aq]example.module-a\[aq]]
        ...
        no file \[aq]./example/module-a.lua\[aq]
        ...
stack traceback:
  [C]: in function \[aq]require\[aq]
  ./libs/example/init.fnl:2: in main chunk
\f[R]
.fi
.PP
LuaRocks addresses this problem by enforcing both the directory name and
installation path, populating the \f[V]LUA_PATH\f[R] environment
variable to make the library available.
This, of course, can be done manually by setting \f[V]LUA_PATH\f[R] per
project in the build pipeline, pointing it to the right directory.
But this is not very transparent, and when requiring a project local
library it\[aq]s better to see the full path, that directly maps to the
project\[aq]s file structure, rather than looking up where the
\f[V]LUA_PATH\f[R] is modified.
.PP
In the Fennel ecosystem we encourage a simpler way of managing project
dependencies.
Simply dropping a library into your project\[aq]s tree or using git
submodule is usually enough, and the require paths should be handled by
the library itself.
.PP
Here\[aq]s how a relative require path can be specified in the
\f[V]libs/example/init.fnl\f[R] to make it name/path agnostic, assuming
that we\[aq]ve moved our \f[V]example\f[R] library there:
.IP
.nf
\f[C]
;; file libs/example/init.fnl:
(local a (require (.. ... :.module-a)))

{:hello-a a.hello}
\f[R]
.fi
.PP
Now, it doesn\[aq]t matter how library is named or where we put it - we
can require it from anywhere.
It works because when requiring the library with
\f[V](require :lib.example)\f[R], the first value in \f[V]...\f[R] will
hold the \f[V]\[dq]lib.example\[dq]\f[R] string.
This string is then concatenated with the \f[V]\[dq].module-a\[dq]\f[R],
and \f[V]require\f[R] will properly find and load the nested module at
runtime under the \f[V]\[dq]lib.example.module-a\[dq]\f[R] path.
It\[aq]s a Lua feature, and not something Fennel specific, and it will
work the same when the library is AOT compiled to Lua.
.SS Compile-time relative include
.PP
Since Fennel v0.10.0 this also works at compile-time, when using the
\f[V]include\f[R] special or the \f[V]--require-as-include\f[R] flag,
with the constraint that the expression can be computed at compile time.
This means that the expression must be self-contained, i.e.
doesn\[aq]t refer to locals or globals, but embeds all values directly.
In other words, the following code will only work at runtime, but not
with \f[V]include\f[R] or \f[V]--require-as-include\f[R] because
\f[V]current-module\f[R] is not known at compile time:
.IP
.nf
\f[C]
(local current-module ...)
(require (.. current-module :.other-module))
\f[R]
.fi
.PP
This, on the other hand, will work both at runtime and at compile time:
.IP
.nf
\f[C]
(require (.. ... :.other-module))
\f[R]
.fi
.PP
The \f[V]...\f[R] module args are propagated during compilation, so when
the application which uses this library is compiled, all library code is
correctly included into the self-contained Lua file.
.PP
Compiling a project that uses this \f[V]example\f[R] library with
\f[V]--require-as-include\f[R] will include the following section in the
resulting Lua code:
.IP
.nf
\f[C]
package.preload[\[dq]libs.example.module-a\[dq]] = package.preload[\[dq]libs.example.module-a\[dq]] or function(...)
  local function hello()
    return print(\[dq]hello from a\[dq])
  end
  return {hello = hello}
end
\f[R]
.fi
.PP
Note that the \f[V]package.preload\f[R] entry contains a fully qualified
path \f[V]\[dq]libs.example.module-a\[dq]\f[R], which was resolved at
compile time.
.SS Requiring modules from modules other than \f[V]init.fnl\f[R]
.PP
To require a module from a module other than \f[V]init\f[R] module, we
must keep the path up to the current module, but remove the module name.
For example, let\[aq]s add a \f[V]greet\f[R] module in
\f[V]libs/example/utils/greet.fnl\f[R], and require it from
\f[V]libs/example/module-a.fnl\f[R]:
.IP
.nf
\f[C]
;; file libs/example/utils/greet.fnl:
(fn greet [who] (print (.. \[dq]hello \[dq] who)))
\f[R]
.fi
.PP
This module can be required as follows:
.IP
.nf
\f[C]
;; file libs/example/module-a.fnl
(local greet (require (.. (: ... :match \[dq](.+)%.[\[ha].]+\[dq]) :.utils.greet)))

(fn hello [] (print \[dq]hello from a\[dq]))

{:hello hello :greet greet}
\f[R]
.fi
.PP
The parent module name is determined via calling the \f[V]match\f[R]
method on the current module name string (\f[V]...\f[R]).
.SH AUTHORS
Fennel Maintainers.
